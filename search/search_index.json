{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#liquidpy","title":"liquidpy","text":"<p>A port of liquid template engine for python, on the shoulders of jinja2</p> <p> </p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install -U liquidpy\n</code></pre>"},{"location":"#playground","title":"Playground","text":"<p>Powered by pyscript:</p> <p>https://pwwang.github.io/liquidpy/playground</p>"},{"location":"#baisic-usage","title":"Baisic usage","text":""},{"location":"#loading-a-template","title":"Loading a template","text":"<pre><code>from liquid import Liquid\nliq = Liquid('{{a}}', from_file=False)\nret = liq.render(a = 1)\n# ret == '1'\n\n# load template from a file\nliq = Liquid('/path/to/template.html')\n</code></pre> <p>Using jinja's environment <pre><code>from jinja2 import Environment, FileSystemLoader\nenv = Environment(loader=FileSystemLoader('./'), ...)\n\nliq = Liquid.from_env(\"/path/to/template.html\", env)\n</code></pre></p>"},{"location":"#switching-to-a-different-mode","title":"Switching to a different mode","text":"<pre><code>liq = Liquid(\n    \"\"\"\n    {% python %}\n    from os import path\n    filename = path.join(\"a\", \"b\")\n    {% endpython %}\n    {{filename}}\n    \"\"\",\n    mode=\"wild\" # supported: standard(default), jekyll, shopify, wild\n)\nliq.render()\n# 'a/b'\n</code></pre>"},{"location":"#changing-default-options","title":"Changing default options","text":"<pre><code>from liquid import defaults, Liquid\ndefaults.FROM_FILE = False\ndefaults.MODE = 'wild'\n\n# no need to pass from_file and mode anymore\nliq = Liquid('{% from_ os import path %}{{path.basename(\"a/b.txt\")}}')\nliq.render()\n# 'b.txt'\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Liquidpy's documentation</li> <li>Liquid documentation (standard)</li> <li>Liquid documentation (jekyll)</li> <li>Liquid documentation (shopify-extended)</li> <li>Jinja2's documentation</li> </ul>"},{"location":"CHANGELOG/","title":"CHANGELOG","text":""},{"location":"CHANGELOG/#change-log","title":"Change Log","text":""},{"location":"CHANGELOG/#086","title":"0.8.6","text":"<ul> <li>fix: fix for \"{{*\" when there is no leading white spaces</li> </ul>"},{"location":"CHANGELOG/#085","title":"0.8.5","text":"<ul> <li>fix: update playground to use pyscript 2024.1.1</li> <li>ci: update action description for clarity</li> <li>ci: add Python 3.13 to test matrix</li> <li>chore: update pyproject.toml for dev dependencies and Python version support</li> <li>test: remove unused import</li> </ul>"},{"location":"CHANGELOG/#084","title":"0.8.4","text":"<ul> <li>feat: add 'each' filter in wild mode</li> </ul>"},{"location":"CHANGELOG/#083-housekeeping","title":"0.8.3 (housekeeping)","text":"<ul> <li>dep: bump up dependencies</li> <li>style: fix code styles in tests</li> <li>ci: update actions</li> <li>chore(deps): bump jinja2 to 3.1.5</li> <li>ci: separate tests for python3.7</li> </ul>"},{"location":"CHANGELOG/#082","title":"0.8.2","text":"<ul> <li>deps: bump jinja2 to 3.1.3</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":"<ul> <li>\ud83d\udcdd Fix badges in README.md</li> <li>\ud83d\udc77 Use latest actions in CI</li> <li>\ud83c\udfd7\ufe0f Enable automatic setup file creation with Poetry</li> <li>\u2b06\ufe0f Upgrade dependencies to the latest</li> <li>\u2728 Add <code>*</code> modifier for variable block to keep intial indention for multiline strings for all modes</li> <li>\ud83d\udcdd Update doc for \"indent modifier\"</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>\u2b06\ufe0f Upgrade deps including markdown, regex, and python-slugify</li> <li>\ud83d\udccc Drop support for python3.6</li> <li>\ud83d\udc1b Fix passing <code>env</code> to <code>Liquid()</code> not working</li> </ul>"},{"location":"CHANGELOG/#076","title":"0.7.6","text":"<ul> <li>\ud83d\udc1b Fix JSON/list parsing in certain cases (#50)</li> </ul>"},{"location":"CHANGELOG/#075","title":"0.7.5","text":"<ul> <li>\u2728 Implement a playground powered by pyscript</li> <li>\u2728 Add filter <code>call</code> for <code>wild</code> mode</li> </ul>"},{"location":"CHANGELOG/#074","title":"0.7.4","text":"<ul> <li>\u2705 Add tests regarding #47</li> <li>\ud83d\udccc Upgrade and pin dependencies</li> </ul>"},{"location":"CHANGELOG/#073","title":"0.7.3","text":"<ul> <li>\ud83e\ude79 Make <code>default</code> filter work with <code>None</code></li> <li>\ud83e\ude79 Make <code>attr</code> filter work with dicts</li> <li>\ud83e\ude79 Use filter <code>liquid_map</code>, in wild mode, instead of <code>map</code>, which is overridden by python's builtin <code>map</code></li> </ul>"},{"location":"CHANGELOG/#072","title":"0.7.2","text":"<ul> <li>\ud83d\udc1b Fix <code>date</code> filter issues (#38, #40)</li> <li>\u2728 Add <code>markdownify</code> for jekyll (#36, #37)</li> <li>\u2728 Add <code>number_of_words</code> for jekyll</li> <li>\u2728 Add jekyll filter <code>sort</code></li> <li>\u2728 Add jekyll filter <code>slugify</code></li> <li>\u2728 Add jekyll filter <code>array_to_sentence_string</code></li> <li>\u2728 Add jekyll filter <code>jsonify</code></li> <li>\u2728 Add jekyll filters <code>xml_escape</code>, <code>cgi_escape</code> and <code>uri_escape</code></li> <li>\u2728 Add <code>int</code>, <code>float</code>, <code>str</code> and <code>bool</code> as both filters and globals for all modes (#40)</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>\u2728 Add <code>regex_replace</code> filter</li> <li>\u2728 Allow absolute path and pathlib.Path passed as template files</li> <li>\u2728 Allow <code>+/-</code> to work with date filter (#38)</li> <li>\u2728 Add <code>filters_as_globals</code> for wild mode (defaults to <code>True</code>)</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>Reimplement using jinja2</li> </ul>"},{"location":"CHANGELOG/#064","title":"0.6.4","text":"<p>Last release of 0.6, for compatibilities.</p> <ul> <li>Add regex_replace filter (#33)</li> </ul>"},{"location":"CHANGELOG/#063","title":"0.6.3","text":"<ul> <li>Allow tag for to have output(test | filter) in python mode.</li> <li>Fix stacks not print in some cases.</li> <li>Avoid closing stream after parsing</li> <li>Add better error message for attribute error while rendering</li> <li>Print 'KeyError' for render error if it is a KeyError.</li> </ul>"},{"location":"CHANGELOG/#062","title":"0.6.2","text":"<ul> <li>Update dependency versions</li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":"<ul> <li>Fix use of LiquidPython</li> <li>Add getitem and render filter for python mode</li> <li>Fix EmptyDrop for variable segment in python mode</li> <li>Fix re-rendering error for extends tag (#29)</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":"<ul> <li>Remodel the package to use a lexer to scan the nodes first and then lark-parse to parse the tag.</li> </ul>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":"<ul> <li>Extract major model of node to allow <code>register_node</code> (#18)</li> <li>Introduce <code>config</code> node and deprecate <code>mode</code></li> <li>Allow specification of directories to scan for <code>include</code> and <code>extends</code> (#19)</li> <li>Add loglevel <code>detail</code> to enable verbosity between <code>info</code> and <code>debug</code></li> <li>Allow passing variables to included templates (#8)</li> <li>Disallow variables in parent templates to be modified in included templates</li> <li>Require backtick <code>( ` )</code> for liquidpy expression to be used in statement nodes</li> <li>Add API documentations</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Implement issue #13: Adding ternary end modifier (<code>$</code>)</li> <li>Expand list/dict context in debug information</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Force explict modifiers (=/!) for True/False action in ternary filters</li> <li>Add combined ternary filters</li> <li>Add shortcut <code>?</code> for <code>?bool</code></li> <li>Use the maximum lineno on traceback instead of the last one.</li> </ul>"},{"location":"CHANGELOG/#023","title":"0.2.3","text":"<ul> <li>Fix parsing errors when unicode in a template loaded from text #10 (thanks to vermeeca)</li> </ul>"},{"location":"CHANGELOG/#022","title":"0.2.2","text":"<ul> <li>Show shortened context in debug information</li> <li>Fix #9: stream cursor shifted when unicode in the template.</li> </ul>"},{"location":"CHANGELOG/#021","title":"0.2.1","text":"<ul> <li>Fix #7: forloop problem with nesting for statements</li> <li>Fix other bugs</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Add inclusion and inheritance support</li> <li>Add <code>cycle</code> for <code>for</code> loop</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Rewrite whole engine using a stream parser</li> <li>Support multi-line for statements, expressions and tag comments (#1)</li> <li>Support wrapper (instead of a single prefix) for statement comments</li> <li>Add <code>from</code> and <code>import</code> shortcuts to import python modules</li> <li>Support expressions in <code>if/unless/while</code> statements</li> <li>Support <code>liquid</code> <code>forloop</code> object for <code>for</code> statement (#2)</li> <li>Improve debug information</li> <li>Add arguemtn position specification for filters</li> <li>Add tenary filters</li> <li>Remove <code>&amp;</code> modifiers</li> </ul>"},{"location":"CHANGELOG/#007","title":"0.0.7","text":"<ul> <li>Allow <code>{% mode %}</code> block to be anywhere in the source code</li> <li>Full the coverage</li> <li>Change support only for python3.5+</li> </ul>"},{"location":"CHANGELOG/#006","title":"0.0.6","text":"<ul> <li>Add modifiers <code>&amp;</code> and <code>*</code> to allow chaining and expanding arguments</li> </ul>"},{"location":"basics/","title":"Basics","text":""},{"location":"basics/#mode-of-a-template","title":"Mode of a template","text":"<p><code>liquidpy</code> supports 4 modes:</p> <ul> <li>standard<ul> <li>try to be compatible with standard liquid template engine</li> <li>See: https://shopify.github.io/liquid/</li> </ul> </li> <li>jekyll<ul> <li>try to be compatible with jekyll liquid template engine</li> <li>See: https://jekyllrb.com/docs/liquid/</li> </ul> </li> <li>shopify<ul> <li>try to be compatible with shopify-extended liquid template engine</li> <li>See: https://shopify.dev/api/liquid</li> </ul> </li> <li>wild<ul> <li>With some wild features supported (i.e. executing python code inside the template)</li> <li>See: https://pwwang.github.io/liquidpy/wild</li> </ul> </li> </ul> <p>See also an introduction about liquid template engine variants:</p> <ul> <li>https://shopify.github.io/liquid/basics/variations/</li> </ul> <p>By default, <code>liquidpy</code> uses the <code>standard</code> mode. But you can specify a mode using the <code>mode</code> argument of <code>Liquid</code> constructor or <code>Liquid.from_env()</code> method.</p> <p>You can changed the default by: <pre><code>from liquid import defaults\ndefaults.MODE = 'wild'\n</code></pre> before you initialize a <code>Liquid</code> object.</p>"},{"location":"basics/#preset-globals-and-filters","title":"Preset globals and filters","text":"<p>If you want to send a set of global variables and filters to the templates:</p> <pre><code>from liquid import Liquid, defaults\ndefaults.FROM_FILE = False\n\na = 1\nb = 2\n\nLiquid(\"{{a | plus: b}}\", globals=globals()).render()\n# '3'\n</code></pre> <p>Specify predefined filters:</p> <pre><code>import os\nfrom liquid import Liquid, defaults\ndefaults.FROM_FILE = False\n\nLiquid(\"{{'/a' | path_join: 'b'}}\", filters={'path_join': os.path.join}).render()\n# '/a/b'\n</code></pre>"},{"location":"basics/#relationship-with-jinja23","title":"Relationship with Jinja2/3","text":"<p>Most features here are implemented by jinja extensions. Some of them, however, are impossible to implement via extensions. So we monkey-patched jinja to be better compatible with liquid syntax.</p> <p>Note</p> <p>If you want jinja to work as its original way, remember to unpatch it before you parse and render your template:</p> <pre><code>from jinja2 import Template\nfrom liquid import Liquid, patch_jinja, unpatch_jinja\n\nliq_tpl = Liquid(...)\nliq_tpl.render(...) # works\n\njinja_tpl = Template(...) # error may happen\njinja_tpl.render(...) # error may happen\n\nunpatch_jinja() # restore jinja\njinja_tpl = Template(...) # works\njinja_tpl.render(...) # works\n\nliq_tpl.render(...) # error may happen\n\npatch_jinja() # patch jinja again\nliq_tpl.render(...) # works\n</code></pre> <p>Most jinja features are supported unless the filters/tags are overriden. For example, the <code>round()</code> filter acts differently then the one in <code>jinja</code>.</p> <p>We could say that the implementations of <code>liquid</code> and its variants are super sets of them themselves, with some slight compatibility issues (See <code>Compatilities</code> below.)</p>"},{"location":"basics/#whitespace-control","title":"Whitespace control","text":"<p>The whitespace control behaves the same as it describes here:</p> <ul> <li>https://shopify.github.io/liquid/basics/whitespace/</li> </ul>"},{"location":"basics/#compatibilies","title":"Compatibilies","text":"<p>See the compatiblity issues for truthy/falsy, tags, and other aspects on pages:</p> <ul> <li>Standard: https://pwwang.github.com/liquidpy/standard</li> <li>Jekyll: https://pwwang.github.com/liquidpy/jekyll</li> <li>Shopify: https://pwwang.github.com/liquidpy/shopify</li> </ul>"},{"location":"basics/#wild-mode","title":"Wild mode","text":"<p>You can do arbitrary things with the wild mode, like executing python code and adding custom filters inside the template.</p> <p>See details on:</p> <ul> <li>https://pwwang.github.com/liquidpy/wild</li> </ul>"},{"location":"basics/#modifier-for-to-keep-initial-indention-along-multiple-lines","title":"<code>*</code> modifier for <code>{{</code> to keep initial indention along multiple lines","text":"<pre><code>tpl = \"\"\"\\\nif True:\n    {{* body }}\n\"\"\"\nbody = \"\"\"\\\nprint('hello')\nprint('world')\n\"\"\"\nprint(Liquid(tpl, from_file=False).render(body=body))\n</code></pre> <pre><code>if True:\n    print('hello')\n    print('world')\n</code></pre>"},{"location":"jekyll/","title":"Compatibility with jekyll liquid","text":"<p>You may checkout the documentation for jekyll liquid:</p> <ul> <li>https://jekyllrb.com/docs/liquid/</li> </ul> <p>The compatibility issues list on:</p> <ul> <li>https://pwwang.github.com/liquidpy/standard</li> </ul> <p>also applied in jekyll mode. Besides, passing variables to a sub-template using <code>include</code> tag is not supported. Instead, please using jinja's <code>with</code> tag:</p> <ul> <li>https://stackoverflow.com/a/9405157/5088165</li> </ul>"},{"location":"shopify/","title":"Compatibility with shopify-extended liquid","text":"<p>You may checkout the documentation for shopfiy liquid:</p> <ul> <li>https://shopify.dev/api/liquid</li> </ul> <p>The compatibility issues list on:</p> <ul> <li>https://pwwang.github.com/liquidpy/standard</li> </ul> <p>also applied in shopify mode.</p>"},{"location":"standard/","title":"Compatibility with standard liquid","text":"<p>You may checkout the documentation for standard liquid: - https://shopify.github.io/liquid/</p> <p><code>liquidpy</code> tries to maintain the maximum compatibility with <code>liquid</code>. But we do have some differences:</p>"},{"location":"standard/#filter-round","title":"Filter <code>round()</code>","text":"<p>It always returns a <code>float</code> rather than an <code>integer</code> when <code>ndigits=0</code></p>"},{"location":"standard/#logical-operators","title":"Logical operators","text":"<p>The logical operators <code>and</code>/<code>or</code> collapse from left to right (it's right to left in <code>liquid</code>)</p> <p>See: https://shopify.github.io/liquid/basics/operators/#order-of-operations</p>"},{"location":"standard/#truthy-and-falsy","title":"Truthy and falsy","text":"<p>Instead of always truthy for empty string, 0, empty array, they are falsy in <code>liquidpy</code></p>"},{"location":"standard/#iteration","title":"Iteration","text":"<p>Literal ranges (<code>(1..5)</code>) are suported by <code>liquidpy</code>. However, the start and the stop must be integers or names, meaning this is not supported <code>(1..array.size)</code>. You can do this instead:</p> <pre><code>{% assign asize = array.size %}\n{% for i in (1..asize) %}\n...\n{% endfor %}\n</code></pre>"},{"location":"standard/#typecasting","title":"Typecasting","text":"<p>You are able to do the following in ruby liquid: <pre><code>{{ \"1\" | plus: 1}}  # 2\n</code></pre> However, this is not valid in liquidpy. Because the template is eventually compiled into python code and the type handling is delegated to python, but \"1\" + 1 is not a valid python operation.</p> <p>So you have to do typecasting yourself: <pre><code>{{ \"1\" | int | plus: 1 }}  # 2\n</code></pre></p> <p>In order to make it work, extra filters <code>int</code>, <code>float</code>, <code>str</code> and <code>bool</code> are added as builtin filters. They are also added as globals in order to get this work: <pre><code>{% capture lst_size %}4{% endcapture %}\n{{ 2 | at_most: int(lst_size) }}  # 2\n</code></pre></p> <p>See also: https://github.com/pwwang/liquidpy/issues/40</p>"},{"location":"wild/","title":"Wild mode","text":"<p>Wild mode tries to introduce more flexiblities for the template. It's very arbitrary for one to do things inside the template. So security is not it's first priority.</p> <p>Warning</p> <p>Do not trust any templates in wild mode with <code>liquidpy</code></p> <p>Below are some features it supports.</p>"},{"location":"wild/#globals","title":"Globals","text":"<ul> <li>By default, wild mode loads all <code>__builtins__</code> as global variables, except those whose names start with <code>_</code>.</li> <li><code>nil</code> is also loaded and intepreted as <code>None</code>.</li> <li>Other globals if not overridden by the above:<ul> <li>See: https://jinja.palletsprojects.com/en/3.0.x/templates/?highlight=builtin%20filters#list-of-global-functions</li> </ul> </li> </ul>"},{"location":"wild/#filters","title":"Filters","text":"<ul> <li>All builtin functions are loaded as filters, except those whose names starts with <code>_</code> and not in: <code>\"copyright\", \"credits\", \"input\", \"help\", \"globals\", \"license\", \"locals\", \"memoryview\", \"object\", \"property\", \"staticmethod\", \"super\"</code>.</li> <li>Filters from standard mode are loaded</li> <li>Builtin jinja filters are enabled if not overridden by the above filters<ul> <li>See: https://jinja.palletsprojects.com/en/3.0.x/templates/?highlight=builtin%20filters#builtin-filters</li> </ul> </li> <li><code>ifelse</code>:<ul> <li>See: https://pwwang.github.io/liquidpy/api/liquid.filters.wild/</li> </ul> </li> <li><code>map()</code>:<ul> <li>It is overridden by python's <code>builtins.map()</code>. To use the one from <code>liquid</code>, try <code>liquid_map()</code></li> </ul> </li> <li><code>each()</code>:<ul> <li>Call a function for each item in an array. With wild mode, you can use the 'map' filter to apply a function to each item in an array. However, this filter is different from the 'map' filter in that it takes the array as the first argument and additional arguments passed to the function are allowed.</li> </ul> </li> </ul>"},{"location":"wild/#tests","title":"Tests","text":"<p>All jinja tests are supported</p> <p>See: https://jinja.palletsprojects.com/en/3.0.x/templates/#builtin-tests</p>"},{"location":"wild/#tags","title":"Tags","text":"<p><code>liquidpy</code> wild mode supports a set of tags that we can do arbitrary things.</p>"},{"location":"wild/#python-tag","title":"<code>python</code> tag","text":"<p>The <code>python</code> tag allows you to execute arbitrary code inside a template. It supports single line mode and block mode.</p> <p>If you just want execute a single line of python code:</p> <pre><code>{% python a = 1 %}\n</code></pre> <p>Or if you want to execute a chunk of code: <pre><code>{% python %}\ndef func(x)\n    ...\nb = func(a)\n{% endpython %}\n</code></pre></p> <p>Note</p> <p>The <code>python</code> tag can only interact with the global variables. The variables in the context (<code>Context.vars</code>) cannot be referred and will not be affected.</p> <p>In the above examples, the first will write variable <code>a</code> the <code>environment.globals</code> or overwrite it. The second will use variable <code>a</code> in <code>environment.globals</code> and then write <code>b</code> to it.</p> <p>Tip</p> <p>Any variables declared at top level of the code gets stored in the <code>environment.globals</code>. If you don't want some to be stored, you should delete them using <code>del</code></p> <p>Tip</p> <p>The code will be dedentated using <code>textwrap.dedent</code> and then send to <code>exec</code>. So: <pre><code>{% python %}[space][space]a\n[space][space]b\n{% endpython %}\n</code></pre> works as expected. But you can also write it like this: <pre><code>{% python %}\n[space][space]a\n[space][space]b\n{% endpython %}\n</code></pre> The first non-spaced line will be ignored.</p> <p>Tip</p> <p>You can also print stuff inside the code, which will be parsed as literals.</p>"},{"location":"wild/#import_-and-from_-tags","title":"<code>import_</code> and <code>from_</code> tags","text":"<p>The <code>import_</code> and <code>from_</code> tags help users to import python modules into the <code>environment.globals</code>. It works the same as python's <code>import</code> and <code>from ... import ...</code></p> <p>Note</p> <p>The <code>import</code> and <code>from</code> from jinja are kept and work as they are in jinja.</p>"},{"location":"wild/#addfilter-tag","title":"<code>addfilter</code> tag","text":"<p>This allows one to add a filter using python code. For example:</p> <p><pre><code>{% addfilter trunc %}\ndef trunc(string, n):\n    return string[:n]\n{% endaddfilter %}\n{{ a | trunc: 3 }}\n</code></pre> When render with <code>a=\"abcde\"</code>, it gives: <code>'abc'</code></p> <p>Like the <code>python</code> tag, you can only use the variables in <code>environment.globals</code> inside the code. But unlike the <code>python</code> tag, anything you print inside the code will be ignored.</p> <p>You can also define a filter with the environment:</p> <pre><code>{% addfilter render pass_env %}\ndef render(env, expr, **kwargs):\n    compiled = env.compile_expression(expr)\n    return compiled(**kwargs)\n{% endaddfilter %}\n{{ \"item | plus(1)\" | render: a }}\n</code></pre> <p>When render with <code>a=1</code>, it gives <code>2</code>.</p> <p>Note</p> <p>The expresison passed to <code>env.compile_expression()</code> has to use the jinja-supported syntax (i.e. using colon to separate filter and its arguments is not supported).</p> <p>This is useful when you want to render an template expression insdie the template.</p>"},{"location":"wild/#extensions","title":"Extensions","text":"<ul> <li><code>jinja2.ext.debug</code> is enabled</li> </ul>"},{"location":"api/liquid.defaults/","title":"liquid.defaults","text":"module &lt;/&gt; <p>Provide default settings/values</p>"},{"location":"api/liquid.defaults/#liquiddefaults","title":"liquid.defaults","text":""},{"location":"api/liquid.exts.ext/","title":"liquid.exts.ext","text":"module &lt;/&gt; <p>Provides a base extension class</p> Classes <ul> <li><code>LiquidExtension</code> \u2014 A base extension class for extensions in this package to extend&lt;/&gt;</li> </ul> class &lt;/&gt; Bases jinja2.ext.Extension <p>A base extension class for extensions in this package to extend</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 Initalize the tags and raw_tags using tag manager&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> (Union(tokenstream, iterable of token)) \u2014 It's passed a :class:<code>~jinja2.lexer.TokenStream</code> that can be usedto filter tokens returned.  This method has to return an iterable of :class:<code>~jinja2.lexer.Token</code>\\s, but it doesn't have to return a :class:<code>~jinja2.lexer.TokenStream</code>. &lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Node) \u2014 Let tag manager to parse the tags that are being listened to&lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>It's passed a :class:<code>~jinja2.lexer.TokenStream</code> that can be usedto filter tokens returned.  This method has to return an iterable of :class:<code>~jinja2.lexer.Token</code>\\s, but it doesn't have to return a :class:<code>~jinja2.lexer.TokenStream</code>.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> classmethod &lt;/&gt; <p>Initalize the tags and raw_tags using tag manager</p> method &lt;/&gt; <p>Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia.</p> method &lt;/&gt; <p>Let tag manager to parse the tags that are being listened to</p>"},{"location":"api/liquid.exts.ext/#liquidextsext","title":"liquid.exts.ext","text":""},{"location":"api/liquid.exts.ext/#liquidextsextliquidextension","title":"<code>liquid.exts.ext.</code><code>LiquidExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.ext/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.ext/#jinja2extextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2192 Union(tokenstream, iterable of token)","text":""},{"location":"api/liquid.exts.ext/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.ext/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.ext/#liquidextsextliquidextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.ext/#liquidextsextliquidextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.ext/#liquidextsextliquidextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Node","text":""},{"location":"api/liquid.exts.filter_colon/","title":"liquid.exts.filter_colon","text":"module &lt;/&gt; <p>Provides an extension to use colon to separate filter and its arguments</p><p>Jinja uses <code>{{a | filter(arg)}}</code>, but liquid uses <code>{{a | filter: arg}}</code></p> Classes <ul> <li><code>FilterColonExtension</code> \u2014 This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters &lt;/&gt;</li> </ul> class &lt;/&gt; Bases jinja2.ext.Extension <p>This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 This method is called when a class is subclassed.&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> (Token) \u2014 Modify the colon to lparen and rparen tokens&lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Union(node, list of node)) \u2014 If any of the :attr:<code>tags</code> matched this method is called with theparser as first argument.  The token the parser stream is pointing at is the name token that matched.  This method has to return one or a list of multiple nodes. &lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 This method is called before the actual lexing and can be used topreprocess the source.  The <code>filename</code> is optional.  The return value must be the preprocessed source. &lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>This method is called when a class is subclassed.</p><p>The default implementation does nothing. It may be overridden to extend subclasses.</p> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>This method is called before the actual lexing and can be used topreprocess the source.  The <code>filename</code> is optional.  The return value must be the preprocessed source.</p> method &lt;/&gt; <p>If any of the :attr:<code>tags</code> matched this method is called with theparser as first argument.  The token the parser stream is pointing at is the name token that matched.  This method has to return one or a list of multiple nodes.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> generator &lt;/&gt; <p>Modify the colon to lparen and rparen tokens</p>"},{"location":"api/liquid.exts.filter_colon/#liquidextsfilter_colon","title":"liquid.exts.filter_colon","text":""},{"location":"api/liquid.exts.filter_colon/#liquidextsfilter_colonfiltercolonextension","title":"<code>liquid.exts.filter_colon.</code><code>FilterColonExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.filter_colon/#jinja2extextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename=None</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Union(node, list of node)","text":""},{"location":"api/liquid.exts.filter_colon/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.filter_colon/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.filter_colon/#liquidextsfilter_colonfiltercolonextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2192 Token","text":""},{"location":"api/liquid.exts.front_matter/","title":"liquid.exts.front_matter","text":"module &lt;/&gt; <p>Provides an extension to allow front matter in the template</p> Classes <ul> <li><code>FrontMatterExtension</code> \u2014 This extension allows to have front matter&lt;/&gt;</li> </ul> class &lt;/&gt; Bases jinja2.ext.Extension <p>This extension allows to have front matter</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 This method is called when a class is subclassed.&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> (Union(tokenstream, iterable of token)) \u2014 It's passed a :class:<code>~jinja2.lexer.TokenStream</code> that can be usedto filter tokens returned.  This method has to return an iterable of :class:<code>~jinja2.lexer.Token</code>\\s, but it doesn't have to return a :class:<code>~jinja2.lexer.TokenStream</code>. &lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Union(node, list of node)) \u2014 If any of the :attr:<code>tags</code> matched this method is called with theparser as first argument.  The token the parser stream is pointing at is the name token that matched.  This method has to return one or a list of multiple nodes. &lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 Preprocess sourcee to extract front matter&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>This method is called when a class is subclassed.</p><p>The default implementation does nothing. It may be overridden to extend subclasses.</p> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>It's passed a :class:<code>~jinja2.lexer.TokenStream</code> that can be usedto filter tokens returned.  This method has to return an iterable of :class:<code>~jinja2.lexer.Token</code>\\s, but it doesn't have to return a :class:<code>~jinja2.lexer.TokenStream</code>.</p> method &lt;/&gt; <p>If any of the :attr:<code>tags</code> matched this method is called with theparser as first argument.  The token the parser stream is pointing at is the name token that matched.  This method has to return one or a list of multiple nodes.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> method &lt;/&gt; <p>Preprocess sourcee to extract front matter</p>"},{"location":"api/liquid.exts.front_matter/#liquidextsfront_matter","title":"liquid.exts.front_matter","text":""},{"location":"api/liquid.exts.front_matter/#liquidextsfront_matterfrontmatterextension","title":"<code>liquid.exts.front_matter.</code><code>FrontMatterExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.front_matter/#jinja2extextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.front_matter/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.front_matter/#jinja2extextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2192 Union(tokenstream, iterable of token)","text":""},{"location":"api/liquid.exts.front_matter/#jinja2extextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Union(node, list of node)","text":""},{"location":"api/liquid.exts.front_matter/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.front_matter/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.front_matter/#liquidextsfront_matterfrontmatterextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename=None</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.jekyll/","title":"liquid.exts.jekyll","text":"module &lt;/&gt; <p>Extension for jekyll mode</p> Classes <ul> <li><code>LiquidJekyllExtension</code> \u2014 Extension for jekyll mode&lt;/&gt;</li> </ul> class &lt;/&gt; Bases liquid.exts.standard.LiquidStandardExtension liquid.exts.ext.LiquidExtension jinja2.ext.Extension <p>Extension for jekyll mode</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 Initalize the tags and raw_tags using tag manager&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2014 Supports for liquid features&lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Node) \u2014 Let tag manager to parse the tags that are being listened to&lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> classmethod &lt;/&gt; <p>Initalize the tags and raw_tags using tag manager</p> method &lt;/&gt; <p>Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia.</p> method &lt;/&gt; <p>Let tag manager to parse the tags that are being listened to</p> generator &lt;/&gt; <p>Supports for liquid features</p>"},{"location":"api/liquid.exts.jekyll/#liquidextsjekyll","title":"liquid.exts.jekyll","text":""},{"location":"api/liquid.exts.jekyll/#liquidextsjekyllliquidjekyllextension","title":"<code>liquid.exts.jekyll.</code><code>LiquidJekyllExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.jekyll/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.jekyll/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.jekyll/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.jekyll/#liquidextsextliquidextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.jekyll/#liquidextsextliquidextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.jekyll/#liquidextsextliquidextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Node","text":""},{"location":"api/liquid.exts.jekyll/#liquidextsstandardliquidstandardextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code>","text":""},{"location":"api/liquid.exts/","title":"liquid.exts","text":"package &lt;/&gt; module &lt;/&gt; <p>Provides an extension to allow front matter in the template</p> Classes <ul> <li><code>FrontMatterExtension</code> \u2014 This extension allows to have front matter&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides a base extension class</p> Classes <ul> <li><code>LiquidExtension</code> \u2014 A base extension class for extensions in this package to extend&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Extension for jekyll mode</p> Classes <ul> <li><code>LiquidJekyllExtension</code> \u2014 Extension for jekyll mode&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides extension for wild mode</p> Classes <ul> <li><code>LiquidWildExtension</code> \u2014 Extension for wild mode&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides an extension to implment features for standard liquid</p> Classes <ul> <li><code>LiquidStandardExtension</code> \u2014 This extension implement features for standard liqiud&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides an extension to use colon to separate filter and its arguments</p><p>Jinja uses <code>{{a | filter(arg)}}</code>, but liquid uses <code>{{a | filter: arg}}</code></p> Classes <ul> <li><code>FilterColonExtension</code> \u2014 This extension allows colon to be used to separatethe filter and arguments, so that we can write django/liquid-style filters &lt;/&gt;</li> </ul> module &lt;/&gt; <p>Extension for shopify mode</p> Classes <ul> <li><code>LiquidShopifyExtension</code> \u2014 Extension for jekyll mode&lt;/&gt;</li> </ul>"},{"location":"api/liquid.exts/#liquidexts","title":"liquid.exts","text":""},{"location":"api/liquid.exts/#liquidextsfront_matter","title":"liquid.exts.front_matter","text":""},{"location":"api/liquid.exts/#liquidextsext","title":"liquid.exts.ext","text":""},{"location":"api/liquid.exts/#liquidextsjekyll","title":"liquid.exts.jekyll","text":""},{"location":"api/liquid.exts/#liquidextswild","title":"liquid.exts.wild","text":""},{"location":"api/liquid.exts/#liquidextsstandard","title":"liquid.exts.standard","text":""},{"location":"api/liquid.exts/#liquidextsfilter_colon","title":"liquid.exts.filter_colon","text":""},{"location":"api/liquid.exts/#liquidextsshopify","title":"liquid.exts.shopify","text":""},{"location":"api/liquid.exts.shopify/","title":"liquid.exts.shopify","text":"module &lt;/&gt; <p>Extension for shopify mode</p> Classes <ul> <li><code>LiquidShopifyExtension</code> \u2014 Extension for jekyll mode&lt;/&gt;</li> </ul> class &lt;/&gt; Bases liquid.exts.standard.LiquidStandardExtension liquid.exts.ext.LiquidExtension jinja2.ext.Extension <p>Extension for jekyll mode</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 Initalize the tags and raw_tags using tag manager&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2014 Supports for liquid features&lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Node) \u2014 Let tag manager to parse the tags that are being listened to&lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> classmethod &lt;/&gt; <p>Initalize the tags and raw_tags using tag manager</p> method &lt;/&gt; <p>Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia.</p> method &lt;/&gt; <p>Let tag manager to parse the tags that are being listened to</p> generator &lt;/&gt; <p>Supports for liquid features</p>"},{"location":"api/liquid.exts.shopify/#liquidextsshopify","title":"liquid.exts.shopify","text":""},{"location":"api/liquid.exts.shopify/#liquidextsshopifyliquidshopifyextension","title":"<code>liquid.exts.shopify.</code><code>LiquidShopifyExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.shopify/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.shopify/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.shopify/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.shopify/#liquidextsextliquidextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.shopify/#liquidextsextliquidextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.shopify/#liquidextsextliquidextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Node","text":""},{"location":"api/liquid.exts.shopify/#liquidextsstandardliquidstandardextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code>","text":""},{"location":"api/liquid.exts.standard/","title":"liquid.exts.standard","text":"module &lt;/&gt; <p>Provides an extension to implment features for standard liquid</p> Classes <ul> <li><code>LiquidStandardExtension</code> \u2014 This extension implement features for standard liqiud&lt;/&gt;</li> </ul> class &lt;/&gt; Bases liquid.exts.ext.LiquidExtension jinja2.ext.Extension <p>This extension implement features for standard liqiud</p><p>These features (that jinja does support) including 1. Allow '.size' to get length of an array (by replacing it     with '.len()') 2. Allow 'contains' to work as an operator by turning it into a test 3. Turn 'forloop' to 'loop' 4. Allow <code>(1..5)</code>, which will be turned to <code>range(1, 6)</code></p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 Initalize the tags and raw_tags using tag manager&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2014 Supports for liquid features&lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Node) \u2014 Let tag manager to parse the tags that are being listened to&lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> classmethod &lt;/&gt; <p>Initalize the tags and raw_tags using tag manager</p> method &lt;/&gt; <p>Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia.</p> method &lt;/&gt; <p>Let tag manager to parse the tags that are being listened to</p> generator &lt;/&gt; <p>Supports for liquid features</p>"},{"location":"api/liquid.exts.standard/#liquidextsstandard","title":"liquid.exts.standard","text":""},{"location":"api/liquid.exts.standard/#liquidextsstandardliquidstandardextension","title":"<code>liquid.exts.standard.</code><code>LiquidStandardExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.standard/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.standard/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.standard/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.standard/#liquidextsextliquidextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.standard/#liquidextsextliquidextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.standard/#liquidextsextliquidextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Node","text":""},{"location":"api/liquid.exts.standard/#liquidextsstandardliquidstandardextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code>","text":""},{"location":"api/liquid.exts.wild/","title":"liquid.exts.wild","text":"module &lt;/&gt; <p>Provides extension for wild mode</p> Classes <ul> <li><code>LiquidWildExtension</code> \u2014 Extension for wild mode&lt;/&gt;</li> </ul> class &lt;/&gt; Bases liquid.exts.ext.LiquidExtension jinja2.ext.Extension <p>Extension for wild mode</p> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 Initalize the tags and raw_tags using tag manager&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>name</code>, <code>lineno</code><code>)</code> (ExtensionAttribute) \u2014 Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code. &lt;/&gt;</li> <li><code>bind</code><code>(</code><code>environment</code><code>)</code> (te.Self) \u2014 Create a copy of this extension bound to another environment.&lt;/&gt;</li> <li><code>call_method</code><code>(</code><code>name</code>, <code>args</code>, <code>kwargs</code>, <code>dyn_args</code>, <code>dyn_kwargs</code>, <code>lineno</code><code>)</code> (Call) \u2014 Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>. &lt;/&gt;</li> <li><code>filter_stream</code><code>(</code><code>stream</code><code>)</code> (Union(tokenstream, iterable of token)) \u2014 It's passed a :class:<code>~jinja2.lexer.TokenStream</code> that can be usedto filter tokens returned.  This method has to return an iterable of :class:<code>~jinja2.lexer.Token</code>\\s, but it doesn't have to return a :class:<code>~jinja2.lexer.TokenStream</code>. &lt;/&gt;</li> <li><code>parse</code><code>(</code><code>parser</code><code>)</code> (Node) \u2014 Let tag manager to parse the tags that are being listened to&lt;/&gt;</li> <li><code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> (str) \u2014 Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia. &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a copy of this extension bound to another environment.</p> method &lt;/&gt; <p>It's passed a :class:<code>~jinja2.lexer.TokenStream</code> that can be usedto filter tokens returned.  This method has to return an iterable of :class:<code>~jinja2.lexer.Token</code>\\s, but it doesn't have to return a :class:<code>~jinja2.lexer.TokenStream</code>.</p> method &lt;/&gt; <p>Return an attribute node for the current extension.  This is usefulto pass constants on extensions to generated template code.</p> <p>::</p> <pre><code>self.attr('_my_attribute', lineno=lineno)\n</code></pre> method &lt;/&gt; <p>Call a method of the extension.  This is a shortcut for:meth:<code>attr</code> + :class:<code>jinja2.nodes.Call</code>.</p> classmethod &lt;/&gt; <p>Initalize the tags and raw_tags using tag manager</p> method &lt;/&gt; <p>Try to keep the tag body raw by encode the variable/comment/blockstart strings ('{{', '{#', '{%') so that the body won't be tokenized by jinjia.</p> method &lt;/&gt; <p>Let tag manager to parse the tags that are being listened to</p>"},{"location":"api/liquid.exts.wild/#liquidextswild","title":"liquid.exts.wild","text":""},{"location":"api/liquid.exts.wild/#liquidextswildliquidwildextension","title":"<code>liquid.exts.wild.</code><code>LiquidWildExtension</code><code>(</code><code>environment</code><code>)</code>","text":""},{"location":"api/liquid.exts.wild/#jinja2extextensionbind","title":"<code>bind</code><code>(</code><code>environment</code><code>)</code> \u2192 te.Self","text":""},{"location":"api/liquid.exts.wild/#jinja2extextensionfilter_stream","title":"<code>filter_stream</code><code>(</code><code>stream</code><code>)</code> \u2192 Union(tokenstream, iterable of token)","text":""},{"location":"api/liquid.exts.wild/#jinja2extextensionattr","title":"<code>attr</code><code>(</code><code>name</code>, <code>lineno=None</code><code>)</code> \u2192 ExtensionAttribute","text":""},{"location":"api/liquid.exts.wild/#jinja2extextensioncall_method","title":"<code>call_method</code><code>(</code><code>name</code>, <code>args=None</code>, <code>kwargs=None</code>, <code>dyn_args=None</code>, <code>dyn_kwargs=None</code>, <code>lineno=None</code><code>)</code> \u2192 Call","text":""},{"location":"api/liquid.exts.wild/#liquidextsextliquidextensioninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.exts.wild/#liquidextsextliquidextensionpreprocess","title":"<code>preprocess</code><code>(</code><code>source</code>, <code>name</code>, <code>filename</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.exts.wild/#liquidextsextliquidextensionparse","title":"<code>parse</code><code>(</code><code>parser</code><code>)</code> \u2192 Node","text":""},{"location":"api/liquid.filters.jekyll/","title":"liquid.filters.jekyll","text":"module &lt;/&gt; <p>Provides jekyll filtersSee: https://jekyllrb.com/docs/liquid/filters/</p> Functions <ul> <li><code>absolute_url</code><code>(</code><code>env</code>, <code>value</code><code>)</code> \u2014 Get absolute url based on site.baseurl&lt;/&gt;</li> <li><code>array_to_sentence_string</code><code>(</code><code>array</code>, <code>connector</code><code>)</code> (str) \u2014 Join an array of things into a string by separating with commas and theword \"and\" for the last one. &lt;/&gt;</li> <li><code>cgi_escape</code><code>(</code><code>input</code><code>)</code> (str) \u2014 CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. &lt;/&gt;</li> <li><code>date_to_xmlschema</code><code>(</code><code>env</code>, <code>value</code><code>)</code> \u2014 Convert date to xml schema format&lt;/&gt;</li> <li><code>find</code><code>(</code><code>value</code>, <code>attr</code>, <code>query</code><code>)</code> \u2014 Find elements from array using attribute value&lt;/&gt;</li> <li><code>find_exp</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code> \u2014 Find elements using expression&lt;/&gt;</li> <li><code>group_by_expr</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code> \u2014 Group by data using expression&lt;/&gt;</li> <li><code>jekyll_slugify</code><code>(</code><code>input</code>, <code>mode</code><code>)</code> (str) \u2014 Slugify a string&lt;/&gt;</li> <li><code>jekyll_sort</code><code>(</code><code>array</code>, <code>prop</code>, <code>none_pos</code><code>)</code> \u2014 Sort an array in a reverse way by default.&lt;/&gt;</li> <li><code>jsonify</code><code>(</code><code>input</code><code>)</code> (str) \u2014 Convert the input into json string&lt;/&gt;</li> <li><code>markdownify</code><code>(</code><code>value</code><code>)</code> \u2014 Markdownify a string&lt;/&gt;</li> <li><code>normalize_whitespace</code><code>(</code><code>value</code><code>)</code> \u2014 Replace multiple spaces into one&lt;/&gt;</li> <li><code>number_of_words</code><code>(</code><code>input</code>, <code>mode</code><code>)</code> (int) \u2014 Count the number of words in the input string.&lt;/&gt;</li> <li><code>relative_url</code><code>(</code><code>env</code>, <code>value</code><code>)</code> \u2014 Get relative url based on site.baseurl&lt;/&gt;</li> <li><code>sample</code><code>(</code><code>value</code>, <code>n</code><code>)</code> \u2014 Sample elements from array&lt;/&gt;</li> <li><code>uri_escape</code><code>(</code><code>input</code><code>)</code> (str) \u2014 URI escape a string.&lt;/&gt;</li> <li><code>where_exp</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code> \u2014 Where using expression&lt;/&gt;</li> <li><code>xml_escape</code><code>(</code><code>input</code><code>)</code> (str) \u2014 Convert an object into its String representation&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Get relative url based on site.baseurl</p> function &lt;/&gt; <p>Get absolute url based on site.baseurl</p> function &lt;/&gt; <p>Convert date to xml schema format</p> function &lt;/&gt; <p>Where using expression</p> function &lt;/&gt; <p>Find elements from array using attribute value</p> function &lt;/&gt; <p>Find elements using expression</p> function &lt;/&gt; <p>Group by data using expression</p> function &lt;/&gt; <p>Convert an object into its String representation</p> Parameters <ul> <li><code>input</code> (str) \u2014 The object to be converted</li> </ul> Returns (str) <p>The converted string</p> function &lt;/&gt; <p>CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements.</p> Parameters <ul> <li><code>input</code> (str) \u2014 The string to escape</li> </ul> Returns (str) <p>The escaped string</p> function &lt;/&gt; <p>URI escape a string.</p> Parameters <ul> <li><code>input</code> (str) \u2014 The string to escape</li> </ul> Returns (str) <p>The escaped string</p> function &lt;/&gt; <p>Convert the input into json string</p> Parameters <ul> <li><code>input</code> (any) \u2014 The Array or Hash to be converted</li> </ul> Returns (str) <p>The converted json string</p> function &lt;/&gt; <p>Join an array of things into a string by separating with commas and theword \"and\" for the last one.</p> Parameters <ul> <li><code>array</code> (sequence of str) \u2014 The Array of Strings to join.</li> <li><code>connector</code> (str, optional) \u2014 Word used to connect the last 2 items in the array</li> </ul> Returns (str) <p>The formatted string.</p> function &lt;/&gt; <p>Slugify a string</p><p>Note that non-ascii characters are always translated to ascii ones.</p> Parameters <ul> <li><code>input</code> (str) \u2014 The input string</li> <li><code>mode</code> (str, optional) \u2014 How string is slugified</li> </ul> Returns (str) <p>The slugified string</p> function &lt;/&gt; <p>Count the number of words in the input string.</p> Parameters <ul> <li><code>input</code> (str) \u2014 The String on which to operate.</li> <li><code>mode</code> (str, optional) \u2014 Passing 'cjk' as the argument will count every CJK characterdetected as one word irrespective of being separated by whitespace. Passing 'auto' (auto-detect) works similar to 'cjk' </li> </ul> Returns (int) <p>The word count.</p> function &lt;/&gt; <p>Markdownify a string</p> function &lt;/&gt; <p>Replace multiple spaces into one</p> function &lt;/&gt; <p>Sort an array in a reverse way by default.</p><p>Note that the order might be different than it with ruby. For example, in python <code>\"1abc\" &gt; \"1\"</code>, but it's not the case in jekyll. Also, it's always in reverse order for property values.</p> Parameters <ul> <li><code>array</code> \u2014 The array</li> <li><code>prop</code> (str, optional) \u2014 property name</li> <li><code>none_pos</code> (str, optional) \u2014 None order (first or last).</li> </ul> Returns <p>The sorted array</p> function &lt;/&gt; <p>Sample elements from array</p>"},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyll","title":"liquid.filters.jekyll","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllrelative_url","title":"<code>liquid.filters.jekyll.</code><code>relative_url</code><code>(</code><code>env</code>, <code>value</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllabsolute_url","title":"<code>liquid.filters.jekyll.</code><code>absolute_url</code><code>(</code><code>env</code>, <code>value</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylldate_to_xmlschema","title":"<code>liquid.filters.jekyll.</code><code>date_to_xmlschema</code><code>(</code><code>env</code>, <code>value</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllwhere_exp","title":"<code>liquid.filters.jekyll.</code><code>where_exp</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllfind","title":"<code>liquid.filters.jekyll.</code><code>find</code><code>(</code><code>value</code>, <code>attr</code>, <code>query</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllfind_exp","title":"<code>liquid.filters.jekyll.</code><code>find_exp</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllgroup_by_expr","title":"<code>liquid.filters.jekyll.</code><code>group_by_expr</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllxml_escape","title":"<code>liquid.filters.jekyll.</code><code>xml_escape</code><code>(</code><code>input</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllcgi_escape","title":"<code>liquid.filters.jekyll.</code><code>cgi_escape</code><code>(</code><code>input</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylluri_escape","title":"<code>liquid.filters.jekyll.</code><code>uri_escape</code><code>(</code><code>input</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylljsonify","title":"<code>liquid.filters.jekyll.</code><code>jsonify</code><code>(</code><code>input</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllarray_to_sentence_string","title":"<code>liquid.filters.jekyll.</code><code>array_to_sentence_string</code><code>(</code><code>array</code>, <code>connector='and'</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylljekyll_slugify","title":"<code>liquid.filters.jekyll.</code><code>jekyll_slugify</code><code>(</code><code>input</code>, <code>mode='default'</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllnumber_of_words","title":"<code>liquid.filters.jekyll.</code><code>number_of_words</code><code>(</code><code>input</code>, <code>mode=None</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllmarkdownify","title":"<code>liquid.filters.jekyll.</code><code>markdownify</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllnormalize_whitespace","title":"<code>liquid.filters.jekyll.</code><code>normalize_whitespace</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekylljekyll_sort","title":"<code>liquid.filters.jekyll.</code><code>jekyll_sort</code><code>(</code><code>array</code>, <code>prop=None</code>, <code>none_pos='first'</code><code>)</code>","text":""},{"location":"api/liquid.filters.jekyll/#liquidfiltersjekyllsample","title":"<code>liquid.filters.jekyll.</code><code>sample</code><code>(</code><code>value</code>, <code>n=1</code><code>)</code>","text":""},{"location":"api/liquid.filters.manager/","title":"liquid.filters.manager","text":"module &lt;/&gt; <p>Provides filter manager</p> Classes <ul> <li><code>FilterManager</code> \u2014 A manager for filters&lt;/&gt;</li> </ul> class &lt;/&gt; <p>A manager for filters</p> Attributes <ul> <li><code>filters</code> (dict(str: )) \u2014 a mapping of filter names to filters</li> </ul> Methods <ul> <li><code>register</code><code>(</code><code>name_or_filter</code><code>)</code> \u2014 Register a filter&lt;/&gt;</li> <li><code>update_to_env</code><code>(</code><code>env</code>, <code>overwrite</code><code>)</code> \u2014 Update the filters to environment&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Register a filter</p><p>This can be used as a decorator</p> Examples <pre><code>&gt;&gt;&gt; @filter_manager.register&gt;&gt;&gt; def add(a, b):\n&gt;&gt;&gt;   return a+b\n&gt;&gt;&gt; # register it with an alias:\n&gt;&gt;&gt; @filter_manager.register('addfunc')\n&gt;&gt;&gt; def add(a, b):\n&gt;&gt;&gt;   return a+b\n</code></pre> Parameters <ul> <li><code>name_or_filter</code> (Union(str, sequence of str, ), optional) \u2014 The filter to registerif name is given, will be treated as alias </li> </ul> Returns <p>The registered function or the decorator</p> method &lt;/&gt; <p>Update the filters to environment</p> Parameters <ul> <li><code>env</code> (Environment) \u2014 The environment to update these filters to</li> <li><code>overwrite</code> (bool, optional) \u2014 Whether overwrite existing filters in the env?</li> </ul>"},{"location":"api/liquid.filters.manager/#liquidfiltersmanager","title":"liquid.filters.manager","text":""},{"location":"api/liquid.filters.manager/#liquidfiltersmanagerfiltermanager","title":"<code>liquid.filters.manager.</code><code>FilterManager</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.filters.manager/#liquidfiltersmanagerfiltermanagerregister","title":"<code>register</code><code>(</code><code>name_or_filter=None</code><code>)</code>","text":""},{"location":"api/liquid.filters.manager/#liquidfiltersmanagerfiltermanagerupdate_to_env","title":"<code>update_to_env</code><code>(</code><code>env</code>, <code>overwrite=True</code><code>)</code>","text":""},{"location":"api/liquid.filters/","title":"liquid.filters","text":"package &lt;/&gt; module &lt;/&gt; <p>Provides jekyll filtersSee: https://jekyllrb.com/docs/liquid/filters/</p> Functions <ul> <li><code>absolute_url</code><code>(</code><code>env</code>, <code>value</code><code>)</code> \u2014 Get absolute url based on site.baseurl&lt;/&gt;</li> <li><code>array_to_sentence_string</code><code>(</code><code>array</code>, <code>connector</code><code>)</code> (str) \u2014 Join an array of things into a string by separating with commas and theword \"and\" for the last one. &lt;/&gt;</li> <li><code>cgi_escape</code><code>(</code><code>input</code><code>)</code> (str) \u2014 CGI escape a string for use in a URL. Replaces any special characterswith appropriate %XX replacements. &lt;/&gt;</li> <li><code>date_to_xmlschema</code><code>(</code><code>env</code>, <code>value</code><code>)</code> \u2014 Convert date to xml schema format&lt;/&gt;</li> <li><code>find</code><code>(</code><code>value</code>, <code>attr</code>, <code>query</code><code>)</code> \u2014 Find elements from array using attribute value&lt;/&gt;</li> <li><code>find_exp</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code> \u2014 Find elements using expression&lt;/&gt;</li> <li><code>group_by_expr</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code> \u2014 Group by data using expression&lt;/&gt;</li> <li><code>jekyll_slugify</code><code>(</code><code>input</code>, <code>mode</code><code>)</code> (str) \u2014 Slugify a string&lt;/&gt;</li> <li><code>jekyll_sort</code><code>(</code><code>array</code>, <code>prop</code>, <code>none_pos</code><code>)</code> \u2014 Sort an array in a reverse way by default.&lt;/&gt;</li> <li><code>jsonify</code><code>(</code><code>input</code><code>)</code> (str) \u2014 Convert the input into json string&lt;/&gt;</li> <li><code>markdownify</code><code>(</code><code>value</code><code>)</code> \u2014 Markdownify a string&lt;/&gt;</li> <li><code>normalize_whitespace</code><code>(</code><code>value</code><code>)</code> \u2014 Replace multiple spaces into one&lt;/&gt;</li> <li><code>number_of_words</code><code>(</code><code>input</code>, <code>mode</code><code>)</code> (int) \u2014 Count the number of words in the input string.&lt;/&gt;</li> <li><code>relative_url</code><code>(</code><code>env</code>, <code>value</code><code>)</code> \u2014 Get relative url based on site.baseurl&lt;/&gt;</li> <li><code>sample</code><code>(</code><code>value</code>, <code>n</code><code>)</code> \u2014 Sample elements from array&lt;/&gt;</li> <li><code>uri_escape</code><code>(</code><code>input</code><code>)</code> (str) \u2014 URI escape a string.&lt;/&gt;</li> <li><code>where_exp</code><code>(</code><code>env</code>, <code>value</code>, <code>item</code>, <code>expr</code><code>)</code> \u2014 Where using expression&lt;/&gt;</li> <li><code>xml_escape</code><code>(</code><code>input</code><code>)</code> (str) \u2014 Convert an object into its String representation&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides filter manager</p> Classes <ul> <li><code>FilterManager</code> \u2014 A manager for filters&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides some wild filters</p> Functions <ul> <li><code>call</code><code>(</code><code>fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (any) \u2014 Call a function with passed arguments&lt;/&gt;</li> <li><code>each</code><code>(</code><code>array</code>, <code>fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (any) \u2014 Call a function for each item in an array.&lt;/&gt;</li> <li><code>ifelse</code><code>(</code><code>env</code>, <code>value</code>, <code>test</code>, <code>test_args</code>, <code>true</code>, <code>true_args</code>, <code>false</code>, <code>false_args</code><code>)</code> (any) \u2014 An if-else filter, implementing a tenary-like filter.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides standard liquid filters</p> Classes <ul> <li><code>DateTime</code> \u2014 Date time allows plus/minus operation&lt;/&gt;</li> <li><code>EmptyDrop</code> \u2014 The EmptyDrop class borrowed from liquid&lt;/&gt;</li> </ul> Functions <ul> <li><code>append</code><code>(</code><code>base</code>, <code>suffix</code><code>)</code> \u2014 Append a suffix to a string&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>base</code>, <code>prop</code><code>)</code> \u2014 Similar as <code>__getattr__()</code> but also works like `getitem()&lt;/&gt;</li> <li><code>ceil</code><code>(</code><code>base</code><code>)</code> \u2014 Get the ceil of a number&lt;/&gt;</li> <li><code>compact</code><code>(</code><code>base</code><code>)</code> \u2014 Remove empties from a list&lt;/&gt;</li> <li><code>default</code><code>(</code><code>base</code>, <code>deft</code>, <code>allow_false</code><code>)</code> \u2014 Return the deft value if base is not set.Otherwise, return base &lt;/&gt;</li> <li><code>divided_by</code><code>(</code><code>base</code>, <code>dvdby</code><code>)</code> \u2014 Implementation of / or //&lt;/&gt;</li> <li><code>escape_once</code><code>(</code><code>base</code><code>)</code> \u2014 Escapse html characters only once of the string&lt;/&gt;</li> <li><code>floor</code><code>(</code><code>base</code><code>)</code> \u2014 Get the floor of a number&lt;/&gt;</li> <li><code>liquid_date</code><code>(</code><code>base</code>, <code>fmt</code><code>)</code> \u2014 Format a date/datetime&lt;/&gt;</li> <li><code>liquid_map</code><code>(</code><code>base</code>, <code>prop</code><code>)</code> \u2014 Map a property to a list of objects&lt;/&gt;</li> <li><code>liquid_slice</code><code>(</code><code>base</code>, <code>start</code>, <code>length</code><code>)</code> \u2014 Slice a list&lt;/&gt;</li> <li><code>minus</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of -&lt;/&gt;</li> <li><code>modulo</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of %&lt;/&gt;</li> <li><code>newline_to_br</code><code>(</code><code>base</code><code>)</code> \u2014 Replace newline with <code>&lt;br /&gt;</code>&lt;/&gt;</li> <li><code>plus</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of +&lt;/&gt;</li> <li><code>prepend</code><code>(</code><code>base</code>, <code>prefix</code><code>)</code> \u2014 Prepend a prefix to a string&lt;/&gt;</li> <li><code>regex_replace</code><code>(</code><code>base</code>, <code>regex</code>, <code>replace</code>, <code>case_sensitive</code>, <code>count</code><code>)</code> (str) \u2014 Replace matching regex pattern&lt;/&gt;</li> <li><code>remove</code><code>(</code><code>base</code>, <code>string</code><code>)</code> \u2014 Remove a substring from a string&lt;/&gt;</li> <li><code>remove_first</code><code>(</code><code>base</code>, <code>string</code><code>)</code> \u2014 Remove the first substring from a string&lt;/&gt;</li> <li><code>replace_first</code><code>(</code><code>base</code>, <code>old</code>, <code>new</code><code>)</code> \u2014 Replace the first substring with new string&lt;/&gt;</li> <li><code>sort</code><code>(</code><code>base</code><code>)</code> \u2014 Get the sorted list&lt;/&gt;</li> <li><code>sort_natural</code><code>(</code><code>base</code><code>)</code> \u2014 Get the sorted list in a case-insensitive manner&lt;/&gt;</li> <li><code>split</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Split a string into a listIf the sep is empty, return the list of characters &lt;/&gt;</li> <li><code>strip_html</code><code>(</code><code>base</code><code>)</code> \u2014 Strip html tags from a string&lt;/&gt;</li> <li><code>strip_newlines</code><code>(</code><code>base</code><code>)</code> \u2014 Strip newlines from a string&lt;/&gt;</li> <li><code>times</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of *&lt;/&gt;</li> <li><code>truncate</code><code>(</code><code>base</code>, <code>length</code>, <code>ellipsis</code><code>)</code> \u2014 Truncate a string&lt;/&gt;</li> <li><code>truncatewords</code><code>(</code><code>base</code>, <code>length</code>, <code>ellipsis</code><code>)</code> \u2014 Truncate a string by words&lt;/&gt;</li> <li><code>uniq</code><code>(</code><code>base</code><code>)</code> \u2014 Get the unique elements from a list&lt;/&gt;</li> <li><code>url_decode</code><code>(</code><code>base</code><code>)</code> \u2014 Url-decode a string&lt;/&gt;</li> <li><code>url_encode</code><code>(</code><code>base</code><code>)</code> \u2014 Url-encode a string&lt;/&gt;</li> <li><code>where</code><code>(</code><code>base</code>, <code>prop</code>, <code>value</code><code>)</code> \u2014 Query a list of objects with a given property value&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides shopify filters</p>"},{"location":"api/liquid.filters/#liquidfilters","title":"liquid.filters","text":""},{"location":"api/liquid.filters/#liquidfiltersjekyll","title":"liquid.filters.jekyll","text":""},{"location":"api/liquid.filters/#liquidfiltersmanager","title":"liquid.filters.manager","text":""},{"location":"api/liquid.filters/#liquidfilterswild","title":"liquid.filters.wild","text":""},{"location":"api/liquid.filters/#liquidfiltersstandard","title":"liquid.filters.standard","text":""},{"location":"api/liquid.filters/#liquidfiltersshopify","title":"liquid.filters.shopify","text":""},{"location":"api/liquid.filters.shopify/","title":"liquid.filters.shopify","text":"module &lt;/&gt; <p>Provides shopify filters</p>"},{"location":"api/liquid.filters.shopify/#liquidfiltersshopify","title":"liquid.filters.shopify","text":""},{"location":"api/liquid.filters.standard/","title":"liquid.filters.standard","text":"module &lt;/&gt; <p>Provides standard liquid filters</p> Classes <ul> <li><code>DateTime</code> \u2014 Date time allows plus/minus operation&lt;/&gt;</li> <li><code>EmptyDrop</code> \u2014 The EmptyDrop class borrowed from liquid&lt;/&gt;</li> </ul> Functions <ul> <li><code>append</code><code>(</code><code>base</code>, <code>suffix</code><code>)</code> \u2014 Append a suffix to a string&lt;/&gt;</li> <li><code>attr</code><code>(</code><code>base</code>, <code>prop</code><code>)</code> \u2014 Similar as <code>__getattr__()</code> but also works like `getitem()&lt;/&gt;</li> <li><code>ceil</code><code>(</code><code>base</code><code>)</code> \u2014 Get the ceil of a number&lt;/&gt;</li> <li><code>compact</code><code>(</code><code>base</code><code>)</code> \u2014 Remove empties from a list&lt;/&gt;</li> <li><code>default</code><code>(</code><code>base</code>, <code>deft</code>, <code>allow_false</code><code>)</code> \u2014 Return the deft value if base is not set.Otherwise, return base &lt;/&gt;</li> <li><code>divided_by</code><code>(</code><code>base</code>, <code>dvdby</code><code>)</code> \u2014 Implementation of / or //&lt;/&gt;</li> <li><code>escape_once</code><code>(</code><code>base</code><code>)</code> \u2014 Escapse html characters only once of the string&lt;/&gt;</li> <li><code>floor</code><code>(</code><code>base</code><code>)</code> \u2014 Get the floor of a number&lt;/&gt;</li> <li><code>liquid_date</code><code>(</code><code>base</code>, <code>fmt</code><code>)</code> \u2014 Format a date/datetime&lt;/&gt;</li> <li><code>liquid_map</code><code>(</code><code>base</code>, <code>prop</code><code>)</code> \u2014 Map a property to a list of objects&lt;/&gt;</li> <li><code>liquid_slice</code><code>(</code><code>base</code>, <code>start</code>, <code>length</code><code>)</code> \u2014 Slice a list&lt;/&gt;</li> <li><code>minus</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of -&lt;/&gt;</li> <li><code>modulo</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of %&lt;/&gt;</li> <li><code>newline_to_br</code><code>(</code><code>base</code><code>)</code> \u2014 Replace newline with <code>&lt;br /&gt;</code>&lt;/&gt;</li> <li><code>plus</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of +&lt;/&gt;</li> <li><code>prepend</code><code>(</code><code>base</code>, <code>prefix</code><code>)</code> \u2014 Prepend a prefix to a string&lt;/&gt;</li> <li><code>regex_replace</code><code>(</code><code>base</code>, <code>regex</code>, <code>replace</code>, <code>case_sensitive</code>, <code>count</code><code>)</code> (str) \u2014 Replace matching regex pattern&lt;/&gt;</li> <li><code>remove</code><code>(</code><code>base</code>, <code>string</code><code>)</code> \u2014 Remove a substring from a string&lt;/&gt;</li> <li><code>remove_first</code><code>(</code><code>base</code>, <code>string</code><code>)</code> \u2014 Remove the first substring from a string&lt;/&gt;</li> <li><code>replace_first</code><code>(</code><code>base</code>, <code>old</code>, <code>new</code><code>)</code> \u2014 Replace the first substring with new string&lt;/&gt;</li> <li><code>sort</code><code>(</code><code>base</code><code>)</code> \u2014 Get the sorted list&lt;/&gt;</li> <li><code>sort_natural</code><code>(</code><code>base</code><code>)</code> \u2014 Get the sorted list in a case-insensitive manner&lt;/&gt;</li> <li><code>split</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Split a string into a listIf the sep is empty, return the list of characters &lt;/&gt;</li> <li><code>strip_html</code><code>(</code><code>base</code><code>)</code> \u2014 Strip html tags from a string&lt;/&gt;</li> <li><code>strip_newlines</code><code>(</code><code>base</code><code>)</code> \u2014 Strip newlines from a string&lt;/&gt;</li> <li><code>times</code><code>(</code><code>base</code>, <code>sep</code><code>)</code> \u2014 Implementation of *&lt;/&gt;</li> <li><code>truncate</code><code>(</code><code>base</code>, <code>length</code>, <code>ellipsis</code><code>)</code> \u2014 Truncate a string&lt;/&gt;</li> <li><code>truncatewords</code><code>(</code><code>base</code>, <code>length</code>, <code>ellipsis</code><code>)</code> \u2014 Truncate a string by words&lt;/&gt;</li> <li><code>uniq</code><code>(</code><code>base</code><code>)</code> \u2014 Get the unique elements from a list&lt;/&gt;</li> <li><code>url_decode</code><code>(</code><code>base</code><code>)</code> \u2014 Url-decode a string&lt;/&gt;</li> <li><code>url_encode</code><code>(</code><code>base</code><code>)</code> \u2014 Url-encode a string&lt;/&gt;</li> <li><code>where</code><code>(</code><code>base</code>, <code>prop</code>, <code>value</code><code>)</code> \u2014 Query a list of objects with a given property value&lt;/&gt;</li> </ul> class &lt;/&gt; <p>Date time allows plus/minus operation</p> Methods <ul> <li><code>__str__</code><code>(</code><code>)</code> (str) \u2014 How it is rendered&lt;/&gt;</li> </ul> method &lt;/&gt; <p>How it is rendered</p> class &lt;/&gt; <p>The EmptyDrop class borrowed from liquid</p> function &lt;/&gt; <p>Split a string into a listIf the sep is empty, return the list of characters</p> function &lt;/&gt; <p>Append a suffix to a string</p> function &lt;/&gt; <p>Prepend a prefix to a string</p> function &lt;/&gt; <p>Implementation of *</p> function &lt;/&gt; <p>Implementation of -</p> function &lt;/&gt; <p>Implementation of +</p> function &lt;/&gt; <p>Implementation of %</p> function &lt;/&gt; <p>Get the ceil of a number</p> function &lt;/&gt; <p>Get the floor of a number</p> function &lt;/&gt; <p>Format a date/datetime</p> function &lt;/&gt; <p>Return the deft value if base is not set.Otherwise, return base</p> function &lt;/&gt; <p>Implementation of / or //</p> function &lt;/&gt; <p>Escapse html characters only once of the string</p> function &lt;/&gt; <p>Replace newline with <code>&lt;br /&gt;</code></p> function &lt;/&gt; <p>Remove a substring from a string</p> function &lt;/&gt; <p>Remove the first substring from a string</p> function &lt;/&gt; <p>Replace the first substring with new string</p> function &lt;/&gt; <p>Get the sorted list</p> function &lt;/&gt; <p>Get the sorted list in a case-insensitive manner</p> function &lt;/&gt; <p>Slice a list</p> function &lt;/&gt; <p>Strip html tags from a string</p> function &lt;/&gt; <p>Strip newlines from a string</p> function &lt;/&gt; <p>Truncate a string</p> function &lt;/&gt; <p>Truncate a string by words</p> function &lt;/&gt; <p>Get the unique elements from a list</p> function &lt;/&gt; <p>Url-decode a string</p> function &lt;/&gt; <p>Url-encode a string</p> function &lt;/&gt; <p>Query a list of objects with a given property value</p> function &lt;/&gt; <p>Map a property to a list of objects</p> function &lt;/&gt; <p>Similar as <code>__getattr__()</code> but also works like `getitem()</p> function &lt;/&gt; <p>Remove empties from a list</p> function &lt;/&gt; <p>Replace matching regex pattern</p>"},{"location":"api/liquid.filters.standard/#liquidfiltersstandard","title":"liquid.filters.standard","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddatetime","title":"<code>liquid.filters.standard.</code><code>DateTime</code><code>(</code><code>dt</code>, <code>fmt</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddatetimestr","title":"<code>__str__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardemptydrop","title":"<code>liquid.filters.standard.</code><code>EmptyDrop</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardsplit","title":"<code>liquid.filters.standard.</code><code>split</code><code>(</code><code>base</code>, <code>sep</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardappend","title":"<code>liquid.filters.standard.</code><code>append</code><code>(</code><code>base</code>, <code>suffix</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardprepend","title":"<code>liquid.filters.standard.</code><code>prepend</code><code>(</code><code>base</code>, <code>prefix</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardtimes","title":"<code>liquid.filters.standard.</code><code>times</code><code>(</code><code>base</code>, <code>sep</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardminus","title":"<code>liquid.filters.standard.</code><code>minus</code><code>(</code><code>base</code>, <code>sep</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardplus","title":"<code>liquid.filters.standard.</code><code>plus</code><code>(</code><code>base</code>, <code>sep</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardmodulo","title":"<code>liquid.filters.standard.</code><code>modulo</code><code>(</code><code>base</code>, <code>sep</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardceil","title":"<code>liquid.filters.standard.</code><code>ceil</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardfloor","title":"<code>liquid.filters.standard.</code><code>floor</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardliquid_date","title":"<code>liquid.filters.standard.</code><code>liquid_date</code><code>(</code><code>base</code>, <code>fmt</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddefault","title":"<code>liquid.filters.standard.</code><code>default</code><code>(</code><code>base</code>, <code>deft</code>, <code>allow_false=False</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandarddivided_by","title":"<code>liquid.filters.standard.</code><code>divided_by</code><code>(</code><code>base</code>, <code>dvdby</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardescape_once","title":"<code>liquid.filters.standard.</code><code>escape_once</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardnewline_to_br","title":"<code>liquid.filters.standard.</code><code>newline_to_br</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardremove","title":"<code>liquid.filters.standard.</code><code>remove</code><code>(</code><code>base</code>, <code>string</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardremove_first","title":"<code>liquid.filters.standard.</code><code>remove_first</code><code>(</code><code>base</code>, <code>string</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardreplace_first","title":"<code>liquid.filters.standard.</code><code>replace_first</code><code>(</code><code>base</code>, <code>old</code>, <code>new</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardsort","title":"<code>liquid.filters.standard.</code><code>sort</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardsort_natural","title":"<code>liquid.filters.standard.</code><code>sort_natural</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardliquid_slice","title":"<code>liquid.filters.standard.</code><code>liquid_slice</code><code>(</code><code>base</code>, <code>start</code>, <code>length=1</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardstrip_html","title":"<code>liquid.filters.standard.</code><code>strip_html</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardstrip_newlines","title":"<code>liquid.filters.standard.</code><code>strip_newlines</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardtruncate","title":"<code>liquid.filters.standard.</code><code>truncate</code><code>(</code><code>base</code>, <code>length</code>, <code>ellipsis='...'</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardtruncatewords","title":"<code>liquid.filters.standard.</code><code>truncatewords</code><code>(</code><code>base</code>, <code>length</code>, <code>ellipsis='...'</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandarduniq","title":"<code>liquid.filters.standard.</code><code>uniq</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardurl_decode","title":"<code>liquid.filters.standard.</code><code>url_decode</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardurl_encode","title":"<code>liquid.filters.standard.</code><code>url_encode</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardwhere","title":"<code>liquid.filters.standard.</code><code>where</code><code>(</code><code>base</code>, <code>prop</code>, <code>value</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardliquid_map","title":"<code>liquid.filters.standard.</code><code>liquid_map</code><code>(</code><code>base</code>, <code>prop</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardattr","title":"<code>liquid.filters.standard.</code><code>attr</code><code>(</code><code>base</code>, <code>prop</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardcompact","title":"<code>liquid.filters.standard.</code><code>compact</code><code>(</code><code>base</code><code>)</code>","text":""},{"location":"api/liquid.filters.standard/#liquidfiltersstandardregex_replace","title":"<code>liquid.filters.standard.</code><code>regex_replace</code><code>(</code><code>base</code>, <code>regex</code>, <code>replace=''</code>, <code>case_sensitive=False</code>, <code>count=0</code><code>)</code> \u2192 str","text":""},{"location":"api/liquid.filters.wild/","title":"liquid.filters.wild","text":"module &lt;/&gt; <p>Provides some wild filters</p> Functions <ul> <li><code>call</code><code>(</code><code>fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (any) \u2014 Call a function with passed arguments&lt;/&gt;</li> <li><code>each</code><code>(</code><code>array</code>, <code>fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (any) \u2014 Call a function for each item in an array.&lt;/&gt;</li> <li><code>ifelse</code><code>(</code><code>env</code>, <code>value</code>, <code>test</code>, <code>test_args</code>, <code>true</code>, <code>true_args</code>, <code>false</code>, <code>false_args</code><code>)</code> (any) \u2014 An if-else filter, implementing a tenary-like filter.&lt;/&gt;</li> </ul> function &lt;/&gt; <p>An if-else filter, implementing a tenary-like filter.</p><p>Use <code>ifelse</code> or <code>if_else</code>.</p> Examples <pre><code>&gt;&gt;&gt; {{ a | ifelse: isinstance, (int, ),&gt;&gt;&gt;                \"plus\", (1, ),\n&gt;&gt;&gt;                \"append\", (\".html\", ) }}\n&gt;&gt;&gt; # 2 when a = 1\n&gt;&gt;&gt; # \"a.html\" when a = \"a\"\n</code></pre> Parameters <ul> <li><code>value</code> (any) \u2014 The base value</li> <li><code>test</code> (any) \u2014 The test callable or filter name</li> <li><code>test_args</code> (any, optional) \u2014 Other args (value as the first arg) for the test</li> <li><code>true</code> (any, optional) \u2014 The callable or filter name when test is True</li> <li><code>true_args</code> (any, optional) \u2014 Other args (value as the first arg) for the trueWhen this is None, return the true callable itself or the name of the filter it self </li> <li><code>false</code> (any, optional) \u2014 The callable or filter name when test is False</li> <li><code>false_args</code> (any, optional) \u2014 Other args (value as the first arg) for the falseWhen this is None, return the false callable itself or the name of the filter it self </li> </ul> Returns (any) <p>The result of true of test result is True otherwise result of false.</p> function &lt;/&gt; <p>Call a function with passed arguments</p> Examples <pre><code>&gt;&gt;&gt; {{ int | call: \"1\" | plus: 1 }}&gt;&gt;&gt; # 2\n</code></pre> Parameters <ul> <li><code>fn</code> \u2014 The callable</li> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 The arguments for the callable</li> </ul> Returns (any) <p>The result of calling the function</p> function &lt;/&gt; <p>Call a function for each item in an array.</p><p>With wild mode, you can use the 'map' filter to apply a function to each item in an array. However, this filter is different from the 'map' filter in that it takes the array as the first argument and additional arguments passed to the function are allowed.</p> Examples <pre><code>&gt;&gt;&gt; {{ floor | map: [1.1, 2.1, 3.1] | list }}&gt;&gt;&gt; # [1, 2, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; {{ [1.1, 2.1, 3.1] | each: floor }}\n&gt;&gt;&gt; # [1, 2, 3]\n&gt;&gt;&gt; {{ [1.1, 2.1, 3.1] | each: plus, 1 }}\n&gt;&gt;&gt; # [2.2, 3.2, 4.2]\n</code></pre> Parameters <ul> <li><code>array</code> (any) \u2014 The array</li> <li><code>fn</code> \u2014 The callable</li> </ul> Returns (any) <p>The result of calling the function for each item in the array</p>"},{"location":"api/liquid.filters.wild/#liquidfilterswild","title":"liquid.filters.wild","text":""},{"location":"api/liquid.filters.wild/#liquidfilterswildifelse","title":"<code>liquid.filters.wild.</code><code>ifelse</code><code>(</code><code>env</code>, <code>value</code>, <code>test</code>, <code>test_args=()</code>, <code>true=None</code>, <code>true_args=()</code>, <code>false=None</code>, <code>false_args=()</code><code>)</code>","text":""},{"location":"api/liquid.filters.wild/#liquidfilterswildcall","title":"<code>liquid.filters.wild.</code><code>call</code><code>(</code><code>fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/liquid.filters.wild/#liquidfilterswildeach","title":"<code>liquid.filters.wild.</code><code>each</code><code>(</code><code>array</code>, <code>fn</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/liquid.liquid/","title":"liquid.liquid","text":"module &lt;/&gt; <p>Provides Liquid class</p> Classes <ul> <li><code>Liquid</code> \u2014 The entrance for the package&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The entrance for the package</p> Examples <pre><code>&gt;&gt;&gt; Liquid('{{a}}', from_file=False)&gt;&gt;&gt; Liquid('template.html')\n</code></pre> Parameters <ul> <li><code>template</code> (PathLike or str) \u2014 The template string or path of the template file</li> <li><code>from_file</code> (bool, optional) \u2014 Whether <code>template</code> is a file path. If True, a<code>FileSystemLoader</code> will be used in the <code>env</code>. </li> <li><code>mode</code> (str, optional) \u2014 The mode of the engine.<ul><li>- standard: Most compatibility with the standard liquid engine</li><li>- jekyll: The jekyll-compatible mode</li><li>- shopify: The shopify-compatible mode</li><li>- wild: The liquid- and jinja-compatible mode</li></ul></li> <li><code>env</code> (Environment, optional) \u2014 The jinja environment</li> <li><code>filter_with_colon</code> (bool, optional) \u2014 Whether enable to use colon to separate filter andits arguments (i.e. <code>{{a | filter: arg}}</code>). If False, will fallback to use parentheses (<code>{{a | filter(arg)}}</code>) </li> <li><code>search_paths</code> (Union(pathlike, str, iterable of pathlike or str), optional) \u2014 The search paths for the template files.This only supports specification of paths. If you need so specify <code>encoding</code> and/or <code>followlinks</code>, you should use jinja's <code>FileSystemLoader</code> </li> <li><code>globals</code> (optional) \u2014 Additional global values to be used to render the template</li> <li><code>filters</code> (optional) \u2014 Additional filters be to used to render the template</li> <li><code>filters_as_globals</code> (bool, optional) \u2014 Whether also use filters as globalsOnly works in wild mode </li> <li><code>**kwargs</code> (any) \u2014 Other arguments for an jinja Environment construction andconfigurations for extensions </li> </ul> Methods <ul> <li><code>from_env</code><code>(</code><code>template</code>, <code>env</code>, <code>from_file</code>, <code>filter_with_colon</code>, <code>filters_as_globals</code>, <code>mode</code><code>)</code> (Liquid) \u2014 Initiate a template from a jinja environment&lt;/&gt;</li> <li><code>render</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> (any) \u2014 Render the template.&lt;/&gt;</li> <li><code>render_async</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> (any) \u2014 Asynchronously render the template&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Render the template.</p><p>You can either pass the values using <code>tpl.render(a=1)</code> or <code>tpl.render({'a': 1})</code></p> method &lt;/&gt; <p>Asynchronously render the template</p> classmethod &lt;/&gt; <p>Initiate a template from a jinja environment</p><p>You should not specify any liquid-related extensions here. They will be added automatically.</p> <p>No search path is allow to be passed here. Instead, use jinja2's loaders or use the constructor to initialize a template.</p> <p>@Args:     template: The template string or path of the template file     env: The jinja environment     from_file: Whether <code>template</code> is a file path. If True, a         <code>FileSystemLoader</code> will be used in the <code>env</code>.     filter_with_colon: Whether enable to use colon to separate filter         and its arguments (i.e. <code>{{a | filter: arg}}</code>). If False, will         fallback to use parentheses (<code>{{a | filter(arg)}}</code>)     filters_as_globals: Whether also use filters as globals         Only works in wild mode     mode: The mode of the engine.         - standard: Most compatibility with the standard liquid engine         - wild: The liquid- and jinja-compatible mode         - jekyll: The jekyll-compatible mode</p> <p>@Returns:     A <code>Liquid</code> object</p>"},{"location":"api/liquid.liquid/#liquidliquid","title":"liquid.liquid","text":""},{"location":"api/liquid.liquid/#liquidliquidliquid","title":"<code>liquid.liquid.</code><code>Liquid</code><code>(</code><code>template</code>, <code>from_file=None</code>, <code>mode=None</code>, <code>env=None</code>, <code>filter_with_colon=None</code>, <code>search_paths=None</code>, <code>globals=None</code>, <code>filters=None</code>, <code>filters_as_globals=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/liquid.liquid/#liquidliquidliquidrender","title":"<code>render</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 any","text":""},{"location":"api/liquid.liquid/#liquidliquidliquidrender_async","title":"<code>render_async</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> \u2192 any","text":""},{"location":"api/liquid.liquid/#liquidliquidliquidfrom_env","title":"<code>from_env</code><code>(</code><code>template</code>, <code>env</code>, <code>from_file=None</code>, <code>filter_with_colon=None</code>, <code>filters_as_globals=None</code>, <code>mode=None</code><code>)</code> \u2192 Liquid","text":""},{"location":"api/liquid/","title":"liquid","text":"package &lt;/&gt; <p>A port of liquid template engine for python on the shoulders of jinja2</p> module &lt;/&gt; <p>Some utils</p> Functions <ul> <li><code>parse_tag_args</code><code>(</code><code>stream</code>, <code>name</code>, <code>lineno</code><code>)</code> (Node) \u2014 Parse arguments for a tag.&lt;/&gt;</li> <li><code>peek_tokens</code><code>(</code><code>stream</code>, <code>n</code><code>)</code> (list of Token) \u2014 Peek ahead 'n' tokens in the token stream, but don't move the cursor&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides Liquid class</p> Classes <ul> <li><code>Liquid</code> \u2014 The entrance for the package&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Patch a couple of jinja functions to implement some featuresthat are impossible or too complex to be implemented by extensions</p> <p>Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for'</p> Functions <ul> <li><code>patch_jinja</code><code>(</code><code>)</code> \u2014 Monkey-patch jinja&lt;/&gt;</li> <li><code>unpatch_jinja</code><code>(</code><code>)</code> \u2014 Restore the patches to jinja&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide default settings/values</p>"},{"location":"api/liquid/#liquid","title":"liquid","text":""},{"location":"api/liquid/#liquidutils","title":"liquid.utils","text":""},{"location":"api/liquid/#liquidliquid","title":"liquid.liquid","text":""},{"location":"api/liquid/#liquidpatching","title":"liquid.patching","text":""},{"location":"api/liquid/#liquiddefaults","title":"liquid.defaults","text":""},{"location":"api/liquid.patching/","title":"liquid.patching","text":"module &lt;/&gt; <p>Patch a couple of jinja functions to implement some featuresthat are impossible or too complex to be implemented by extensions</p> <p>Including 1. Patching Parser.parse to allow 'elsif' in addition to 'elif' 2. Patching LoopContext to allow rindex and rindex0 3. Adding liquid_cycle method to LoopContext to allow cycle to have a name 4. Patching Parser.parse_for to allow arguments for tag 'for'</p> Functions <ul> <li><code>patch_jinja</code><code>(</code><code>)</code> \u2014 Monkey-patch jinja&lt;/&gt;</li> <li><code>unpatch_jinja</code><code>(</code><code>)</code> \u2014 Restore the patches to jinja&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Monkey-patch jinja</p> function &lt;/&gt; <p>Restore the patches to jinja</p>"},{"location":"api/liquid.patching/#liquidpatching","title":"liquid.patching","text":""},{"location":"api/liquid.patching/#liquidpatchingpatch_jinja","title":"<code>liquid.patching.</code><code>patch_jinja</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.patching/#liquidpatchingunpatch_jinja","title":"<code>liquid.patching.</code><code>unpatch_jinja</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.tags.jekyll/","title":"liquid.tags.jekyll","text":"module &lt;/&gt; <p>Provides jekyll tags</p> Functions <ul> <li><code>include_relative</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The {% include_relative ... %} tag&lt;/&gt;</li> </ul> function &lt;/&gt; <p>The {% include_relative ... %} tag</p>"},{"location":"api/liquid.tags.jekyll/#liquidtagsjekyll","title":"liquid.tags.jekyll","text":""},{"location":"api/liquid.tags.jekyll/#liquidtagsjekyllinclude_relative","title":"<code>liquid.tags.jekyll.</code><code>include_relative</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> \u2192 Node","text":""},{"location":"api/liquid.tags.manager/","title":"liquid.tags.manager","text":"module &lt;/&gt; <p>Provide tag manager</p> Classes <ul> <li><code>TagManager</code> \u2014 A manager for tags&lt;/&gt;</li> </ul> Functions <ul> <li><code>decode_raw</code><code>(</code><code>body</code><code>)</code> (str) \u2014 Decode the encoded string in body&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Decode the encoded string in body</p><p>The start string in body is encoded so that they won't be recognized as variable/comment/block by jinja. This way, we can protect the body from being tokenized.</p> Parameters <ul> <li><code>body</code> (str) \u2014 The body</li> </ul> Returns (str) <p>The decoded string.</p> class &lt;/&gt; <p>A manager for tags</p> Attributes <ul> <li><code>envs</code> (dict(str: bool)) \u2014 a mapping of tag names and whether environment should be passedto the parser functions </li> <li><code>names</code> (set of str) \u2014 Get a set of the tag names&lt;/&gt;</li> <li><code>names_raw</code> (set of str) \u2014 Get a set of names of tags whose body will be kept raw&lt;/&gt;</li> <li><code>raws</code> (dict(str: bool)) \u2014 a mapping of tag names and whether the tag body should bekept raw. </li> <li><code>tags</code> (dict(str: )) \u2014 a mapping of tag names and parser functions</li> </ul> Methods <ul> <li><code>parse</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 Calling the parser functions to parse the tags&lt;/&gt;</li> <li><code>register</code><code>(</code><code>name_or_tagparser</code>, <code>env</code>, <code>raw</code><code>)</code> \u2014 Register a filter&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Register a filter</p><p>This can be used as a decorator</p> Examples <pre><code>&gt;&gt;&gt; @tag_manager.register&gt;&gt;&gt; def comment(token, parser):\n&gt;&gt;&gt;     from jinja2 import nodes\n&gt;&gt;&gt;     return nodes.Const(\"\")\n</code></pre> Parameters <ul> <li><code>name_or_tagparser</code> (str or , optional) \u2014 The tag parser to registerif name is given, will be treated as alias </li> <li><code>env</code> (bool, optional) \u2014 Whether we should pass environment to the parser</li> <li><code>raw</code> (bool, optional) \u2014 Whether we should keep the body of the tag raw</li> </ul> Returns <p>The registered parser for the tag or a decorator</p> method &lt;/&gt; <p>Calling the parser functions to parse the tags</p> Parameters <ul> <li><code>env</code> (Environment) \u2014 The environment</li> <li><code>token</code> (Token) \u2014 The token matches the tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p>"},{"location":"api/liquid.tags.manager/#liquidtagsmanager","title":"liquid.tags.manager","text":""},{"location":"api/liquid.tags.manager/#liquidtagsmanagerdecode_raw","title":"<code>liquid.tags.manager.</code><code>decode_raw</code><code>(</code><code>body</code><code>)</code>","text":""},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanager","title":"<code>liquid.tags.manager.</code><code>TagManager</code><code>(</code><code>)</code>","text":""},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerregister","title":"<code>register</code><code>(</code><code>name_or_tagparser=None</code>, <code>env=False</code>, <code>raw=False</code><code>)</code>","text":""},{"location":"api/liquid.tags.manager/#liquidtagsmanagertagmanagerparse","title":"<code>parse</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags/","title":"liquid.tags","text":"package &lt;/&gt; module &lt;/&gt; <p>Provides jekyll tags</p> Functions <ul> <li><code>include_relative</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The {% include_relative ... %} tag&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide tag manager</p> Classes <ul> <li><code>TagManager</code> \u2014 A manager for tags&lt;/&gt;</li> </ul> Functions <ul> <li><code>decode_raw</code><code>(</code><code>body</code><code>)</code> (str) \u2014 Decode the encoded string in body&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides tags for wild mode</p> Functions <ul> <li><code>addfilter</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The addfilter tag {% addfilter name ... %} ... {% endaddfilter %}&lt;/&gt;</li> <li><code>from_</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The from_ tag {% from_ ... %}&lt;/&gt;</li> <li><code>import_</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The import_ tag {% import_ ... %}&lt;/&gt;</li> <li><code>python</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The python tag&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides standard liquid tags</p> Functions <ul> <li><code>assign</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The assign tag {% assign x = ... %}&lt;/&gt;</li> <li><code>capture</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The capture tag {% capture var %}...{% endcapture %}&lt;/&gt;</li> <li><code>case</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The case-when tag {% case x %}{% when y %} ... {% endcase %}&lt;/&gt;</li> <li><code>comment</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The comment tag {% comment %} ... {% endcomment %}&lt;/&gt;</li> <li><code>cycle</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The cycle tag {% cycle ... %}&lt;/&gt;</li> <li><code>decrement</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (list of Node) \u2014 The decrement tag {% decrement x %}&lt;/&gt;</li> <li><code>increment</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (list of Node) \u2014 The increment tag {% increment x %}&lt;/&gt;</li> <li><code>tablerow</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Union(node, list of node)) \u2014 The tablerow tag {% tablerow ... %} ... {% endtablerow %}&lt;/&gt;</li> <li><code>unless</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The unless tag {% unless ... %} ... {% endunless %}&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide shopify tagssee: https://shopify.dev/api/liquid/tags</p>"},{"location":"api/liquid.tags/#liquidtags","title":"liquid.tags","text":""},{"location":"api/liquid.tags/#liquidtagsjekyll","title":"liquid.tags.jekyll","text":""},{"location":"api/liquid.tags/#liquidtagsmanager","title":"liquid.tags.manager","text":""},{"location":"api/liquid.tags/#liquidtagswild","title":"liquid.tags.wild","text":""},{"location":"api/liquid.tags/#liquidtagsstandard","title":"liquid.tags.standard","text":""},{"location":"api/liquid.tags/#liquidtagsshopify","title":"liquid.tags.shopify","text":""},{"location":"api/liquid.tags.shopify/","title":"liquid.tags.shopify","text":"module &lt;/&gt; <p>Provide shopify tagssee: https://shopify.dev/api/liquid/tags</p>"},{"location":"api/liquid.tags.shopify/#liquidtagsshopify","title":"liquid.tags.shopify","text":""},{"location":"api/liquid.tags.standard/","title":"liquid.tags.standard","text":"module &lt;/&gt; <p>Provides standard liquid tags</p> Functions <ul> <li><code>assign</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The assign tag {% assign x = ... %}&lt;/&gt;</li> <li><code>capture</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The capture tag {% capture var %}...{% endcapture %}&lt;/&gt;</li> <li><code>case</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The case-when tag {% case x %}{% when y %} ... {% endcase %}&lt;/&gt;</li> <li><code>comment</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The comment tag {% comment %} ... {% endcomment %}&lt;/&gt;</li> <li><code>cycle</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The cycle tag {% cycle ... %}&lt;/&gt;</li> <li><code>decrement</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (list of Node) \u2014 The decrement tag {% decrement x %}&lt;/&gt;</li> <li><code>increment</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (list of Node) \u2014 The increment tag {% increment x %}&lt;/&gt;</li> <li><code>tablerow</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Union(node, list of node)) \u2014 The tablerow tag {% tablerow ... %} ... {% endtablerow %}&lt;/&gt;</li> <li><code>unless</code><code>(</code><code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The unless tag {% unless ... %} ... {% endunless %}&lt;/&gt;</li> </ul> function &lt;/&gt; <p>The comment tag {% comment %} ... {% endcomment %}</p><p>This tag accepts an argument, which is the prefix to be used for each line in the body. If no prefix provided, the entire body will be ignored (works as the one from liquid)</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The capture tag {% capture var %}...{% endcapture %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The assign tag {% assign x = ... %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The unless tag {% unless ... %} ... {% endunless %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The case-when tag {% case x %}{% when y %} ... {% endcase %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The tablerow tag {% tablerow ... %} ... {% endtablerow %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Union(node, list of node)) <p>The parsed node</p> function &lt;/&gt; <p>The increment tag {% increment x %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (list of Node) <p>The parsed node</p> function &lt;/&gt; <p>The decrement tag {% decrement x %}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (list of Node) <p>The parsed node</p> function &lt;/&gt; <p>The cycle tag {% cycle ... %}</p><p>With name: {% cycle \"name\": \"one\", \"two\", \"three\" %} Without: {% cycle \"one\", \"two\", \"three\" %}</p> <p>Turn these to {{ loop.liquid_cycle(\"one\", \"two\", \"three\", name=...) }}</p> Parameters <ul> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p>"},{"location":"api/liquid.tags.standard/#liquidtagsstandard","title":"liquid.tags.standard","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardcomment","title":"<code>liquid.tags.standard.</code><code>comment</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardcapture","title":"<code>liquid.tags.standard.</code><code>capture</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardassign","title":"<code>liquid.tags.standard.</code><code>assign</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardunless","title":"<code>liquid.tags.standard.</code><code>unless</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardcase","title":"<code>liquid.tags.standard.</code><code>case</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardtablerow","title":"<code>liquid.tags.standard.</code><code>tablerow</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardincrement","title":"<code>liquid.tags.standard.</code><code>increment</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandarddecrement","title":"<code>liquid.tags.standard.</code><code>decrement</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.standard/#liquidtagsstandardcycle","title":"<code>liquid.tags.standard.</code><code>cycle</code><code>(</code><code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.wild/","title":"liquid.tags.wild","text":"module &lt;/&gt; <p>Provides tags for wild mode</p> Functions <ul> <li><code>addfilter</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The addfilter tag {% addfilter name ... %} ... {% endaddfilter %}&lt;/&gt;</li> <li><code>from_</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The from_ tag {% from_ ... %}&lt;/&gt;</li> <li><code>import_</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The import_ tag {% import_ ... %}&lt;/&gt;</li> <li><code>python</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code> (Node) \u2014 The python tag&lt;/&gt;</li> </ul> function &lt;/&gt; <p>The python tag</p><p>{% python %} ... {% endpython %} or {% python ... %}</p> <p>The globals from the enviornment will be used to evaluate the code It also affect the globals from the environment</p> Parameters <ul> <li><code>env</code> (Environment) \u2014 The environment</li> <li><code>token</code> (Token) \u2014 The token matches the tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The import_ tag {% import_ ... %}</p><p>Name it 'import_' so the 'import' tag from jinja can still work</p> Parameters <ul> <li><code>env</code> (Environment) \u2014 The environment</li> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The from_ tag {% from_ ... %}</p><p>Name it 'from_' so the 'from_' tag from jinja can still work</p> Parameters <ul> <li><code>env</code> (Environment) \u2014 The environment</li> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p> function &lt;/&gt; <p>The addfilter tag {% addfilter name ... %} ... {% endaddfilter %}</p><p>This allows one to use the python code inside the body to add a filter or replace an existing filter</p> Parameters <ul> <li><code>env</code> (Environment) \u2014 The environment</li> <li><code>token</code> (Token) \u2014 The token matches tag name</li> <li><code>parser</code> (Parser) \u2014 The parser</li> </ul> Returns (Node) <p>The parsed node</p>"},{"location":"api/liquid.tags.wild/#liquidtagswild","title":"liquid.tags.wild","text":""},{"location":"api/liquid.tags.wild/#liquidtagswildpython","title":"<code>liquid.tags.wild.</code><code>python</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.wild/#liquidtagswildimport_","title":"<code>liquid.tags.wild.</code><code>import_</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.wild/#liquidtagswildfrom_","title":"<code>liquid.tags.wild.</code><code>from_</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.tags.wild/#liquidtagswildaddfilter","title":"<code>liquid.tags.wild.</code><code>addfilter</code><code>(</code><code>env</code>, <code>token</code>, <code>parser</code><code>)</code>","text":""},{"location":"api/liquid.utils/","title":"liquid.utils","text":"module &lt;/&gt; <p>Some utils</p> Functions <ul> <li><code>parse_tag_args</code><code>(</code><code>stream</code>, <code>name</code>, <code>lineno</code><code>)</code> (Node) \u2014 Parse arguments for a tag.&lt;/&gt;</li> <li><code>peek_tokens</code><code>(</code><code>stream</code>, <code>n</code><code>)</code> (list of Token) \u2014 Peek ahead 'n' tokens in the token stream, but don't move the cursor&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Peek ahead 'n' tokens in the token stream, but don't move the cursor</p> Parameters <ul> <li><code>stream</code> (TokenStream) \u2014 The token stream</li> <li><code>n</code> (int, optional) \u2014 n tokens to look at</li> </ul> Returns (list of Token) <p>List of n tokens ahead.</p> function &lt;/&gt; <p>Parse arguments for a tag.</p><p>Only integer and name are allowed as values</p> Examples <pre><code>&gt;&gt;&gt; \"{{tablerow product in products cols:2}}\"&gt;&gt;&gt; parse_tag_args(stream, \"cols\", lineno)\n&gt;&gt;&gt; # returns nodes.Const(2)\n</code></pre> Parameters <ul> <li><code>stream</code> (TokenStream) \u2014 The token stream</li> <li><code>name</code> (str) \u2014 The name of the argument</li> <li><code>lineno</code> (int) \u2014 The lineno</li> </ul> Returns (Node) <p>None if the argument is not pressent otherwise a Const or Name node</p>"},{"location":"api/liquid.utils/#liquidutils","title":"liquid.utils","text":""},{"location":"api/liquid.utils/#liquidutilspeek_tokens","title":"<code>liquid.utils.</code><code>peek_tokens</code><code>(</code><code>stream</code>, <code>n=1</code><code>)</code>","text":""},{"location":"api/liquid.utils/#liquidutilsparse_tag_args","title":"<code>liquid.utils.</code><code>parse_tag_args</code><code>(</code><code>stream</code>, <code>name</code>, <code>lineno</code><code>)</code>","text":""},{"location":"api/source/liquid.defaults/","title":"liquid.defaults","text":""},{"location":"api/source/liquid.defaults/","title":"SOURCE CODE liquid.defaults DOCS","text":"<pre><code>\"\"\"Provide default settings/values\"\"\"\nfrom typing import TYPE_CHECKING\n\n\nif TYPE_CHECKING:\n    from .utils import PathTypeOrIter\n\n# The default mode to initialize a Liquid object\n# - standard: Compatible with standard liquid engine\n# - wild: liquid- and jinja-compatible engine\n# - jekyll: jekyll-compatible engine\nMODE: str = \"standard\"\n\n# Whether the template provided is a file path by default\nFROM_FILE: bool = True\n\n# Whether allow arguments of a filter to be separated\n# by colon (:) with the filter\n# e.g. {{ val | filter: arg1, arg2 }}\n# jinja only supports:\n# {{ val | filter(arg1, arg2)}}\nFILTER_WITH_COLON = True\n\n# The default search paths for templates\n# support absolute paths\nSEARCH_PATHS: \"PathTypeOrIter\" = [\"/\", \"./\"]\n\n# The default format/language for the front matter\n# Should be one of yaml, toml or json\nFRONT_MATTER_LANG = \"yaml\"\n\n# Available jinja Environment arguments\nENV_ARGS = [\n    \"block_start_string\",\n    \"block_end_string\",\n    \"variable_start_string\",\n    \"variable_end_string\",\n    \"comment_start_string\",\n    \"comment_end_string\",\n    \"line_statement_prefix\",\n    \"line_comment_prefix\",\n    \"trim_blocks\",\n    \"lstrip_blocks\",\n    \"newline_sequence\",\n    \"keep_trailing_newline\",\n    \"extensions\",\n    \"optimized\",\n    \"undefined\",\n    \"finalize\",\n    \"autoescape\",\n    \"loader\",\n    \"cache_size\",\n    \"auto_reload\",\n    \"bytecode_cache\",\n    \"enable_async\",\n]\n\n# In case some one wants to use nil\nSHARED_GLOBALS = {\"nil\": None}\n\n# Whether treat filters as globals\n# Only works in wild mode\nFILTERS_AS_GLOBALS = True\n</code></pre>"},{"location":"api/source/liquid.exts.ext/","title":"liquid.exts.ext","text":""},{"location":"api/source/liquid.exts.ext/","title":"SOURCE CODE liquid.exts.ext DOCS","text":"<pre><code>\"\"\"Provides a base extension class\"\"\"\nimport re\nfrom base64 import b64encode\nfrom typing import TYPE_CHECKING\n\nfrom jinja2 import nodes\nfrom jinja2.ext import Extension\n\nif TYPE_CHECKING:\n    from jinja2.parser import Parser\n\n\nre_e = re.escape\nre_c = lambda rex: re.compile(rex, re.DOTALL | re.MULTILINE)\n\n# A unique id to encode the start strings\nENCODING_ID = id(Extension)\n\n\nclass LiquidExtension(Extension):DOCS\n    \"\"\"A base extension class for extensions in this package to extend\"\"\"\n\n    def __init_subclass__(cls) -&gt; None:DOCS\n        \"\"\"Initalize the tags and raw_tags using tag manager\"\"\"\n        cls.tags = cls.tag_manager.names\n        cls.raw_tags = cls.tag_manager.names_raw\n\n    def preprocess(  # type: ignoreDOCS\n        self,\n        source: str,\n        name: str,\n        filename: str,\n    ) -&gt; str:\n        \"\"\"Try to keep the tag body raw by encode the variable/comment/block\n        start strings ('{{', '{#', '{%') so that the body won't be tokenized\n        by jinjia.\n        \"\"\"\n        # Turn\n        # \"  {{* ... }}\" to\n        # \"  {{* ... | indent(2) }}\"\n        # to keep the indent for multiline variables\n        variable_start_re = re_e(self.environment.variable_start_string)\n        variable_end_re = re_e(self.environment.variable_end_string)\n        indent_re = re_c(\n            fr\"^([ \\t]*){variable_start_re}\\*\"\n            \"(.*?)\"\n            fr\"(\\-{variable_end_re}|\\+{variable_end_re}|{variable_end_re})\"\n        )\n        source = indent_re.sub(\n            lambda m: (\n                f\"{m.group(1)}{self.environment.variable_start_string}\"\n                f\"{m.group(2)} | indent({m.group(1)!r}){m.group(3)}\"\n            ),\n            source,\n        )\n\n        if not self.__class__.raw_tags:  # pragma: no cover\n            return super().preprocess(source, name, filename=filename)\n\n        block_start_re = re_e(self.environment.block_start_string)\n        block_end_re = re_e(self.environment.block_end_string)\n        comment_start_re = re_e(self.environment.comment_start_string)\n        to_encode = re_c(\n            f\"({block_start_re}|{variable_start_re}|{comment_start_re})\"\n        )\n\n        def encode_raw(matched):\n            content = to_encode.sub(\n                lambda m: (\n                    f\"$${ENCODING_ID}$\"\n                    f\"{b64encode(m.group(1).encode()).decode()}$$\"\n                ),\n                matched.group(2),\n            )\n            return f\"{matched.group(1)}{content}{matched.group(3)}\"\n\n        for raw_tag in self.__class__.raw_tags:\n            tag_re = re_c(\n                # {% comment \"//\"\n                fr\"({block_start_re}(?:\\-|\\+|)\\s*{raw_tag}\\s*.*?\"\n                # %}\n                fr\"(?:\\-{block_end_re}|\\+{block_end_re}|{block_end_re}))\"\n                # ...\n                fr\"(.*?)\"\n                # {% endcomment\n                fr\"({block_start_re}(?:\\-|\\+|)\\s*end{raw_tag}\\s*\"\n                fr\"(?:\\-{block_end_re}|\\+{block_end_re}|{block_end_re}))\"\n            )\n            source = tag_re.sub(encode_raw, source)\n        return source\n\n    def parse(self, parser: \"Parser\") -&gt; nodes.Node:DOCS\n        \"\"\"Let tag manager to parse the tags that are being listened to\"\"\"\n        token = next(parser.stream)\n        return self.__class__.tag_manager.parse(\n            self.environment, token, parser\n        )\n</code></pre>"},{"location":"api/source/liquid.exts.filter_colon/","title":"liquid.exts.filter_colon","text":""},{"location":"api/source/liquid.exts.filter_colon/","title":"SOURCE CODE liquid.exts.filter_colon DOCS","text":"<pre><code>\"\"\"Provides an extension to use colon to separate filter and its arguments\n\nJinja uses `{{a | filter(arg)}}`, but liquid uses `{{a | filter: arg}}`\n\"\"\"\nfrom typing import TYPE_CHECKING, Iterable\nfrom jinja2.ext import Extension\nfrom jinja2.lexer import (\n    TOKEN_ASSIGN,\n    TOKEN_BLOCK_END,\n    TOKEN_COLON,\n    TOKEN_LPAREN,\n    TOKEN_NAME,\n    TOKEN_PIPE,\n    TOKEN_RPAREN,\n    TOKEN_VARIABLE_END,\n    Token,\n)\n\nif TYPE_CHECKING:\n    from jinja2.lexer import TokenStream\n\n\nclass FilterColonExtension(Extension):DOCS\n    \"\"\"This extension allows colon to be used to separate\n    the filter and arguments, so that we can write django/liquid-style filters\n    \"\"\"\n\n    def filter_stream(self, stream: \"TokenStream\") -&gt; Iterable[Token]:DOCS\n        \"\"\"Modify the colon to lparen and rparen tokens\"\"\"\n        # expect a colon\n        # 0: don't expect to change any {{a | filter: arg}}\n        #    to {{a | filter(arg)}}\n        # 1: expect a filter\n        # 2: expect the colon\n        # 3: expect rparen\n        flag = 0\n\n        for token in stream:\n            # print(token.value, token.type)\n            if flag == 0 and token.type is TOKEN_PIPE:\n                flag = 1\n            elif token.type is TOKEN_NAME and flag == 1:\n                flag = 2\n            elif token.type is TOKEN_COLON and flag == 2:\n                flag = 3\n                token = Token(token.lineno, TOKEN_LPAREN, None)\n            elif token.type is TOKEN_COLON and flag == 3:\n                # {{ a | filter: 1, x: 2}} =&gt; {{ a | filter: 1, x=2}}\n                token = Token(token.lineno, TOKEN_ASSIGN, None)\n            elif (\n                token.type in (TOKEN_VARIABLE_END, TOKEN_BLOCK_END, TOKEN_PIPE)\n                and flag == 3\n            ):\n                flag = 1 if token.type is TOKEN_PIPE else 0\n                yield Token(token.lineno, TOKEN_RPAREN, None)\n            elif token.type in (TOKEN_VARIABLE_END, TOKEN_BLOCK_END):\n                flag = 0\n\n            yield token\n</code></pre>"},{"location":"api/source/liquid.exts.front_matter/","title":"liquid.exts.front_matter","text":""},{"location":"api/source/liquid.exts.front_matter/","title":"SOURCE CODE liquid.exts.front_matter DOCS","text":"<pre><code>\"\"\"Provides an extension to allow front matter in the template\"\"\"\nfrom typing import TYPE_CHECKING\nfrom jinja2.ext import Extension\n\nfrom ..defaults import FRONT_MATTER_LANG\n\nif TYPE_CHECKING:\n    from jinja2 import Environment\n\n\nclass FrontMatterExtension(Extension):DOCS\n    \"\"\"This extension allows to have front matter\"\"\"\n\n    def __init__(self, environment: \"Environment\") -&gt; None:\n        super().__init__(environment)\n        environment.extend(front_matter_lang=FRONT_MATTER_LANG)\n\n    def preprocess(self, source: str, name: str, filename: str = None) -&gt; str:DOCS\n        \"\"\"Preprocess sourcee to extract front matter\"\"\"\n        import frontmatter\n\n        if self.environment.front_matter_lang.lower() == \"toml\":\n            from frontmatter.default_handlers import TOMLHandler as handler\n        elif self.environment.front_matter_lang.lower() == \"json\":\n            from frontmatter.default_handlers import JSONHandler as handler\n        else:\n            from frontmatter.default_handlers import YAMLHandler as handler\n\n        processed = frontmatter.loads(source, handler=handler())\n        self.environment.globals[\"page\"] = processed\n        return processed.content\n</code></pre>"},{"location":"api/source/liquid.exts.jekyll/","title":"liquid.exts.jekyll","text":""},{"location":"api/source/liquid.exts.jekyll/","title":"SOURCE CODE liquid.exts.jekyll DOCS","text":"<pre><code>\"\"\"Extension for jekyll mode\"\"\"\nfrom ..tags.jekyll import jekyll_tags\nfrom .standard import LiquidStandardExtension\n\n\nclass LiquidJekyllExtension(LiquidStandardExtension):DOCS\n    \"\"\"Extension for jekyll mode\"\"\"\n    tag_manager = jekyll_tags\n</code></pre>"},{"location":"api/source/liquid.exts/","title":"liquid.exts","text":""},{"location":"api/source/liquid.exts/","title":"SOURCE CODE liquid.exts DOCS","text":""},{"location":"api/source/liquid.exts.shopify/","title":"liquid.exts.shopify","text":""},{"location":"api/source/liquid.exts.shopify/","title":"SOURCE CODE liquid.exts.shopify DOCS","text":"<pre><code>\"\"\"Extension for shopify mode\"\"\"\nfrom ..tags.shopify import shopify_tags\nfrom .standard import LiquidStandardExtension\n\n\nclass LiquidShopifyExtension(LiquidStandardExtension):DOCS\n    \"\"\"Extension for jekyll mode\"\"\"\n    tag_manager = shopify_tags\n</code></pre>"},{"location":"api/source/liquid.exts.standard/","title":"liquid.exts.standard","text":""},{"location":"api/source/liquid.exts.standard/","title":"SOURCE CODE liquid.exts.standard DOCS","text":"<pre><code>\"\"\"Provides an extension to implment features for standard liquid\"\"\"\n\nfrom typing import TYPE_CHECKING, Generator\nfrom jinja2.lexer import (\n    TOKEN_ADD,\n    TOKEN_COMMA,\n    TOKEN_INTEGER,\n    TOKEN_LPAREN,\n    TOKEN_NAME,\n    TOKEN_RPAREN,\n    TOKEN_DOT,\n    Token,\n)\n\nfrom ..utils import peek_tokens\nfrom ..tags.standard import standard_tags\n\nfrom .ext import LiquidExtension\n\nif TYPE_CHECKING:\n    from jinja2.lexer import TokenStream\n\n\nclass LiquidStandardExtension(LiquidExtension):DOCS\n    \"\"\"This extension implement features for standard liqiud\n\n    These features (that jinja does support) including\n    1. Allow '.size' to get length of an array (by replacing it\n        with '.__len__()')\n    2. Allow 'contains' to work as an operator by turning it into a test\n    3. Turn 'forloop' to 'loop'\n    4. Allow `(1..5)`, which will be turned to `range(1, 6)`\n    \"\"\"\n\n    tag_manager = standard_tags\n\n    def __init__(self, environment):\n        super().__init__(environment)\n        environment.tests[\"contains\"] = lambda cont, elm: cont.__contains__(\n            elm\n        )\n\n    def filter_stream(self, stream: \"TokenStream\") -&gt; Generator:DOCS\n        \"\"\"Supports for liquid features\"\"\"\n        for token in stream:\n            # .size =&gt; .__len__()\n            if token.type is TOKEN_DOT:\n\n                if stream.current.test(\"name:size\"):\n                    stream.skip()  # skip 'size'\n                    yield token\n                    yield Token(token.lineno, \"name\", \"__len__\")\n                    yield Token(token.lineno, \"lparen\", None)\n                    yield Token(token.lineno, \"rparen\", None)\n                else:\n                    yield token\n\n            # turn \"contains\" to \"is contains\" to use \"contains\" as a test\n            elif token.test(\"name:contains\"):\n                yield Token(token.lineno, \"name\", \"is\")\n                yield token\n\n            # turn forloop to loop\n            elif token.test(\"name:forloop\"):\n                # only when we do forloop.xxx\n                if stream.current.type is TOKEN_DOT:\n                    yield Token(token.lineno, \"name\", \"loop\")\n                else:\n                    yield token\n\n            # (a..b) =&gt; range(a, b + 1)\n            elif token.type is TOKEN_LPAREN and stream.current.type in (\n                TOKEN_NAME,\n                TOKEN_INTEGER,\n            ):\n                tokens_ahead = peek_tokens(stream, 5)\n                # print(tokens_ahead)\n                if (\n                    len(tokens_ahead) &lt; 5\n                    or tokens_ahead[0].type not in (TOKEN_INTEGER, TOKEN_NAME)\n                    or tokens_ahead[1].type is not TOKEN_DOT\n                    or tokens_ahead[2].type is not TOKEN_DOT\n                    or tokens_ahead[3].type not in (TOKEN_INTEGER, TOKEN_NAME)\n                    or tokens_ahead[4].type is not TOKEN_RPAREN\n                ):\n                    yield token\n                else:\n                    stream.skip(5)\n                    yield Token(token.lineno, TOKEN_NAME, \"range\")\n                    yield Token(token.lineno, TOKEN_LPAREN, None)\n                    yield tokens_ahead[0]\n                    yield Token(token.lineno, TOKEN_COMMA, None)\n                    yield tokens_ahead[3]\n                    yield Token(token.lineno, TOKEN_ADD, None)\n                    yield Token(token.lineno, TOKEN_INTEGER, 1)  # type: ignore\n                    yield Token(token.lineno, TOKEN_RPAREN, None)\n\n            else:\n                yield token\n</code></pre>"},{"location":"api/source/liquid.exts.wild/","title":"liquid.exts.wild","text":""},{"location":"api/source/liquid.exts.wild/","title":"SOURCE CODE liquid.exts.wild DOCS","text":"<pre><code>\"\"\"Provides extension for wild mode\"\"\"\n\nfrom ..tags.wild import wild_tags\n\nfrom .ext import LiquidExtension\n\n\nclass LiquidWildExtension(LiquidExtension):DOCS\n    \"\"\"Extension for wild mode\"\"\"\n    tag_manager = wild_tags\n</code></pre>"},{"location":"api/source/liquid.filters.jekyll/","title":"liquid.filters.jekyll","text":""},{"location":"api/source/liquid.filters.jekyll/","title":"SOURCE CODE liquid.filters.jekyll DOCS","text":"<pre><code>\"\"\"Provides jekyll filters\nSee: https://jekyllrb.com/docs/liquid/filters/\n\"\"\"\nimport datetime\nimport os\nimport random\nimport re\nimport urllib.parse\nfrom typing import TYPE_CHECKING, Any, Sequence\n\nif TYPE_CHECKING:\n    from jinja2.environment import Environment\n\n\n# environmentfilter deprecated\ntry:\n    from jinja2 import pass_environment\nexcept ImportError:\n    from jinja2 import environmentfilter as pass_environment\n\nfrom jinja2.filters import FILTERS\n\nfrom .manager import FilterManager\n\njekyll_filter_manager = FilterManager()\n\n\ndef _getattr(obj: Any, attr: str) -&gt; Any:\n    \"\"\"Get attribute of an object, if fails, try get item\"\"\"\n    try:\n        return getattr(obj, attr)\n    except AttributeError:\n        return obj[attr]\n\n\ndef _getattr_multi(obj: Any, attr: str) -&gt; Any:\n    \"\"\"Get attribute of an object at multiple levels\n\n    For example: x.a.b = 1, _getattr_multi(x, \"a.b\") == 1\n    \"\"\"\n    attrs = attr.split(\".\")\n    for att in attrs:\n        try:\n            obj = _getattr(obj, att)\n        except (TypeError, KeyError):\n            obj = None\n    return obj\n\n\ndef _get_global_var(env: \"Environment\", name: str, attr: str = None) -&gt; Any:\n    if name not in env.globals:\n        raise ValueError(f\"Global variables has not been set: {name}\")\n\n    out = env.globals[name]\n    if attr is None:  # pragma: no cover\n        return out\n\n    return _getattr(out, attr)\n\n\njekyll_filter_manager.register(\"group_by\")(FILTERS[\"groupby\"])\njekyll_filter_manager.register(\"to_integer\")(FILTERS[\"int\"])\njekyll_filter_manager.register(\"inspect\")(repr)\n\n\n@jekyll_filter_manager.registerDOCS\n@pass_environment\ndef relative_url(env, value):\n    \"\"\"Get relative url based on site.baseurl\"\"\"\n    baseurl = _get_global_var(env, \"site\", \"baseurl\")\n    parts = urllib.parse.urlparse(baseurl)\n    return os.path.join(parts.path, value)\n\n\n@jekyll_filter_manager.registerDOCS\n@pass_environment\ndef absolute_url(env, value):\n    \"\"\"Get absolute url based on site.baseurl\"\"\"\n    baseurl = _get_global_var(env, \"site\", \"baseurl\")\n    return urllib.parse.urljoin(baseurl, value)\n\n\n@jekyll_filter_manager.registerDOCS\n@pass_environment\ndef date_to_xmlschema(env, value: datetime.datetime):\n    \"\"\"Convert date to xml schema format\"\"\"\n    return value.isoformat()\n\n\n# TODO: other date filters\n\n\n@jekyll_filter_manager.registerDOCS\n@pass_environment\ndef where_exp(env, value, item, expr):\n    \"\"\"Where using expression\"\"\"\n    compiled = env.compile_expression(expr)\n    return [itm for itm in value if compiled(**{item: itm})]\n\n\n@jekyll_filter_manager.registerDOCS\ndef find(value, attr, query):\n    \"\"\"Find elements from array using attribute value\"\"\"\n    for item in value:\n        try:\n            if _getattr(item, attr) == query:\n                return item\n        except (KeyError, AttributeError):\n            continue\n    return None\n\n\n@jekyll_filter_manager.registerDOCS\n@pass_environment\ndef find_exp(env, value, item, expr):\n    \"\"\"Find elements using expression\"\"\"\n    compiled = env.compile_expression(expr)\n    for itm in value:\n        try:\n            test = compiled(**{item: itm})\n        except AttributeError:\n            continue\n        if test:\n            return itm\n    return None\n\n\n@jekyll_filter_manager.registerDOCS\n@pass_environment\ndef group_by_expr(env, value, item, expr):\n    \"\"\"Group by data using expression\"\"\"\n    compiled = env.compile_expression(expr)\n    out = {}\n    for itm in value:\n        name = compiled(**{item: itm})\n        out.setdefault(name, []).append(itm)\n    return [{name: name, items: items} for name, items in out.items()]\n\n\n@jekyll_filter_manager.registerDOCS\ndef xml_escape(input: str) -&gt; str:\n    \"\"\"Convert an object into its String representation\n\n    Args:\n        input: The object to be converted\n\n    Returns:\n        The converted string\n    \"\"\"\n    if input is None:\n        return \"\"\n\n    from xml.sax.saxutils import escape\n    return escape(input)\n\n\n@jekyll_filter_manager.registerDOCS\ndef cgi_escape(input: str) -&gt; str:\n    \"\"\"CGI escape a string for use in a URL. Replaces any special characters\n    with appropriate %XX replacements.\n\n    Args:\n        input: The string to escape\n\n    Returns:\n        The escaped string\n    \"\"\"\n    return urllib.parse.quote_plus(input)\n\n\n@jekyll_filter_manager.registerDOCS\ndef uri_escape(input: str) -&gt; str:\n    \"\"\"URI escape a string.\n\n    Args:\n        input: The string to escape\n\n    Returns:\n        The escaped string\n    \"\"\"\n    return urllib.parse.quote(input, safe=\"!*'();:@&amp;=+$,/?#[]\")\n\n\n# TODO: smartify, sassify, scssify\n\n\n@jekyll_filter_manager.registerDOCS\ndef jsonify(input: Any) -&gt; str:\n    \"\"\"Convert the input into json string\n\n    Args:\n        input: The Array or Hash to be converted\n\n    Returns:\n        The converted json string\n    \"\"\"\n    import json\n    return json.dumps(input)\n\n\n@jekyll_filter_manager.registerDOCS\ndef array_to_sentence_string(\n    array: Sequence[str],\n    connector: str = \"and\",\n) -&gt; str:\n    \"\"\"Join an array of things into a string by separating with commas and the\n    word \"and\" for the last one.\n\n    Args:\n        array: The Array of Strings to join.\n        connector: Word used to connect the last 2 items in the array\n\n    Returns:\n        The formatted string.\n    \"\"\"\n    if len(array) == 0:\n        return \"\"\n\n    array = [str(elm) for elm in array]\n    if len(array) == 1:\n        return array[0]\n\n    if len(array) == 2:\n        return f\"{array[0]} {connector} {array[1]}\"\n\n    return \", \".join(array[:-1]) + f\", {connector} {array[-1]}\"\n\n\n@jekyll_filter_manager.register(\"slugify\")DOCS\ndef jekyll_slugify(input: str, mode: str = \"default\") -&gt; str:\n    \"\"\"Slugify a string\n\n    Note that non-ascii characters are always translated to ascii ones.\n\n    Args:\n        input: The input string\n        mode: How string is slugified\n\n    Returns:\n        The slugified string\n    \"\"\"\n    if input is None or mode == \"none\":\n        return input\n\n    from slugify import slugify  # type: ignore\n\n    if mode == \"pretty\":\n        return slugify(input, regex_pattern=r\"[^_.~!$&amp;'()+,;=@\\w]+\")\n    if mode == \"raw\":\n        return slugify(input, regex_pattern=r\"\\s+\")\n\n    return slugify(input)\n\n\n@jekyll_filter_manager.registerDOCS\ndef number_of_words(input: str, mode: str = None) -&gt; int:\n    \"\"\"Count the number of words in the input string.\n\n    Args:\n        input: The String on which to operate.\n        mode: Passing 'cjk' as the argument will count every CJK character\n            detected as one word irrespective of being separated by whitespace.\n            Passing 'auto' (auto-detect) works similar to 'cjk'\n\n    Returns:\n        The word count.\n    \"\"\"\n    import regex\n\n    cjk_charset = r\"\\p{Han}\\p{Katakana}\\p{Hiragana}\\p{Hangul}\"\n    cjk_regex = fr\"[{cjk_charset}]\"\n    word_regex = fr\"[^{cjk_charset}\\s]+\"\n    if mode == \"cjk\":\n        return len(regex.findall(cjk_regex, input)) + len(\n            regex.findall(word_regex, input)\n        )\n    if mode == \"auto\":\n        cjk_count = len(regex.findall(cjk_regex, input))\n        return (\n            len(input.split())\n            if cjk_count == 0\n            else cjk_count + len(regex.findall(word_regex, input))\n        )\n    return len(input.split())\n\n\n@jekyll_filter_manager.registerDOCS\ndef markdownify(value):\n    \"\"\"Markdownify a string\"\"\"\n    from markdown import markdown  # type: ignore\n\n    return markdown(value)\n\n\n@jekyll_filter_manager.registerDOCS\ndef normalize_whitespace(value):\n    \"\"\"Replace multiple spaces into one\"\"\"\n    return re.sub(r\"\\s+\", \" \", value)\n\n\n@jekyll_filter_manager.register(\"sort\")DOCS\ndef jekyll_sort(\n    array: Sequence,\n    prop: str = None,\n    none_pos: str = \"first\",\n) -&gt; Sequence:\n    \"\"\"Sort an array in a reverse way by default.\n\n    Note that the order might be different than it with ruby. For example,\n    in python `\"1abc\" &gt; \"1\"`, but it's not the case in jekyll. Also, it's\n    always in reverse order for property values.\n\n    Args:\n        array: The array\n        prop: property name\n        none_pos: None order (first or last).\n\n    Returns:\n        The sorted array\n    \"\"\"\n    if array is None:\n        raise ValueError(\"Cannot sort None object.\")\n\n    if none_pos not in (\"first\", \"last\"):\n        raise ValueError(\n            f\"{none_pos!r} is not a valid none_pos order. \"\n            \"It must be 'first' or 'last'.\"\n        )\n\n    if prop is None:\n        non_none_arr = [elm for elm in array if elm is not None]\n        n_none = len(array) - len(non_none_arr)\n        sorted_arr = list(sorted(non_none_arr, reverse=True))\n\n        if none_pos == \"first\":\n            return [None] * n_none + sorted_arr\n\n        return sorted_arr + [None] * n_none\n\n    non_none_arr = [\n        elm for elm in array if _getattr_multi(elm, prop) is not None\n    ]\n    none_arr = [elm for elm in array if _getattr_multi(elm, prop) is None]\n    sorted_arr = list(\n        sorted(\n            non_none_arr,\n            key=lambda elm: _getattr_multi(elm, prop),\n            reverse=True,\n        )\n    )\n\n    if none_pos == \"first\":\n        return none_arr + sorted_arr\n\n    return sorted_arr + none_arr\n\n\n@jekyll_filter_manager.registerDOCS\ndef sample(value, n: int = 1):\n    \"\"\"Sample elements from array\"\"\"\n    return random.sample(value, k=n)\n</code></pre>"},{"location":"api/source/liquid.filters.manager/","title":"liquid.filters.manager","text":""},{"location":"api/source/liquid.filters.manager/","title":"SOURCE CODE liquid.filters.manager DOCS","text":"<pre><code>\"\"\"Provides filter manager\"\"\"\nfrom typing import TYPE_CHECKING, Callable, Dict, Sequence, Union\n\nif TYPE_CHECKING:\n    from jinja2 import Environment\n\n\nclass FilterManager:DOCS\n    \"\"\"A manager for filters\n\n    Attributes:\n        filters: a mapping of filter names to filters\n    \"\"\"\n\n    __slots__ = (\"filters\",)\n\n    def __init__(self) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self.filters: Dict[str, Callable] = {}\n\n    def register(DOCS\n        self, name_or_filter: Union[str, Sequence[str], Callable] = None\n    ) -&gt; Callable:\n        \"\"\"Register a filter\n\n        This can be used as a decorator\n\n        Examples:\n            &gt;&gt;&gt; @filter_manager.register\n            &gt;&gt;&gt; def add(a, b):\n            &gt;&gt;&gt;   return a+b\n            &gt;&gt;&gt; # register it with an alias:\n            &gt;&gt;&gt; @filter_manager.register('addfunc')\n            &gt;&gt;&gt; def add(a, b):\n            &gt;&gt;&gt;   return a+b\n\n        Args:\n            name_or_filter: The filter to register\n                if name is given, will be treated as alias\n\n        Returns:\n            The registered function or the decorator\n        \"\"\"\n\n        def decorator(filterfunc: Callable) -&gt; Callable:\n            name = filterfunc.__name__\n            name = [name]  # type: ignore\n\n            if name_or_filter and name_or_filter is not filterfunc:\n                names = name_or_filter\n                if isinstance(names, str):\n                    names = (\n                        nam.strip() for nam in names.split(\",\")\n                    )  # type: ignore\n                name = names  # type: ignore\n            for nam in name:\n                self.filters[nam] = filterfunc\n\n            return filterfunc\n\n        if callable(name_or_filter):\n            return decorator(name_or_filter)\n\n        return decorator\n\n    def update_to_env(DOCS\n        self, env: \"Environment\", overwrite: bool = True\n    ) -&gt; None:\n        \"\"\"Update the filters to environment\n\n        Args:\n            env: The environment to update these filters to\n            overwrite: Whether overwrite existing filters in the env?\n        \"\"\"\n        if overwrite:\n            env.filters.update(self.filters)\n\n        filters = self.filters.copy()\n        filters.update(env.filters)\n        env.filters = filters\n</code></pre>"},{"location":"api/source/liquid.filters/","title":"liquid.filters","text":""},{"location":"api/source/liquid.filters/","title":"SOURCE CODE liquid.filters DOCS","text":""},{"location":"api/source/liquid.filters.shopify/","title":"liquid.filters.shopify","text":""},{"location":"api/source/liquid.filters.shopify/","title":"SOURCE CODE liquid.filters.shopify DOCS","text":"<pre><code>\"\"\"Provides shopify filters\"\"\"\n\nfrom .manager import FilterManager\n\n\nshopify_filter_manager = FilterManager()\n\n# TODO: color filters\n# https://shopify.dev/api/liquid/filters/color-filters\n\n# TODO: font filters\n# https://shopify.dev/api/liquid/filters/font-filters\n\n# TODO: html filters\n# https://shopify.dev/api/liquid/filters/html-filters\n\n# TODO: media filters\n# https://shopify.dev/api/liquid/filters/media-filters\n\n# TODO: metafield filters\n# https://shopify.dev/api/liquid/filters/metafield-filters\n\n# TODO: money filters\n# https://shopify.dev/api/liquid/filters/money-filters\n\n# TODO: string filters\n# https://shopify.dev/api/liquid/filters/string-filters\n\n# TODO: url filters\n# https://shopify.dev/api/liquid/filters/url-filters\n\n# TODO: additional filters\n# https://shopify.dev/api/liquid/filters/additional-filters\n</code></pre>"},{"location":"api/source/liquid.filters.standard/","title":"liquid.filters.standard","text":""},{"location":"api/source/liquid.filters.standard/","title":"SOURCE CODE liquid.filters.standard DOCS","text":"<pre><code>\"\"\"Provides standard liquid filters\"\"\"\nimport re\nimport math\nimport html\nfrom datetime import datetime\n\nfrom jinja2.filters import FILTERS\n\nfrom .manager import FilterManager\n\n\nstandard_filter_manager = FilterManager()\n\n\nclass DateTime:DOCS\n    \"\"\"Date time allows plus/minus operation\"\"\"\n    def __init__(self, dt: datetime, fmt: str) -&gt; None:\n        self.dt = dt\n        self.fmt = fmt\n\n    def __str__(self) -&gt; str:DOCS\n        \"\"\"How it is rendered\"\"\"\n        return self.dt.strftime(self.fmt)\n\n    def __add__(self, other: int) -&gt; int:\n        return int(str(self)) + other\n\n    def __sub__(self, other: int) -&gt; int:\n        return int(str(self)) - other\n\n    def __mul__(self, other: int) -&gt; int:\n        return int(str(self)) * other\n\n    def __floordiv__(self, other: int) -&gt; float:\n        return float(str(self)) // other\n\n    def __mod__(self, other: int) -&gt; int:\n        return int(str(self)) % other\n\n    def __pow__(self, other: int) -&gt; int:  # pragma: no cover\n        return int(str(self)) ** other\n\n    def __truediv__(self, other: int) -&gt; float:  # pragma: no cover\n        return float(str(self)) / other\n\n    def __radd__(self, other: int) -&gt; int:  # pragma: no cover\n        return other + int(str(self))\n\n    def __rsub__(self, other: int) -&gt; int:  # pragma: no cover\n        return other - int(str(self))\n\n    def __rmul__(self, other: int) -&gt; int:  # pragma: no cover\n        return other * int(str(self))\n\n    def __rmod__(self, other: int) -&gt; int:  # pragma: no cover\n        return other % int(str(self))\n\n    def __rpow__(self, other: int) -&gt; int:  # pragma: no cover\n        return other ** int(str(self))\n\n    def __rtruediv__(self, other: int) -&gt; float:  # pragma: no cover\n        return other / float(str(self))\n\n    def __rfloordiv__(self, other: int) -&gt; float:  # pragma: no cover\n        return other // float(str(self))\n\n\nclass EmptyDrop:DOCS\n    \"\"\"The EmptyDrop class borrowed from liquid\"\"\"\n\n    # Use jinja's Undefined instead?\n\n    def __init__(self):\n        setattr(self, \"empty?\", True)\n\n    def __str__(self):\n        return \"\"\n\n    def __eq__(self, other):\n        return not bool(other)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    def __bool__(self):\n        return False\n\n\ndef _get_prop(obj, prop, _raise=False):\n    \"\"\"Get the property of the object, allow via getitem\"\"\"\n    try:\n        return obj[prop]\n    except (TypeError, KeyError):\n        try:\n            return getattr(obj, prop)\n        except AttributeError:\n            if _raise:  # pragma: no cover\n                raise\n            return None\n\n\n# Jinja comes with thses filters\n# standard_filter_manager.register(str.capitalize)\n# standard_filter_manager.register(abs)\n# standard_filter_manager.register(round)\nstandard_filter_manager.register(\"concat\")(list.__add__)\nstandard_filter_manager.register(\"at_least\")(max)\nstandard_filter_manager.register(\"at_most\")(min)\nstandard_filter_manager.register(\"downcase\")(str.lower)\nstandard_filter_manager.register(\"upcase\")(str.upper)\nstandard_filter_manager.register(html.escape)\nstandard_filter_manager.register(str.lstrip)\nstandard_filter_manager.register(str.rstrip)\nstandard_filter_manager.register(str.strip)\nstandard_filter_manager.register(str.replace)\nstandard_filter_manager.register(\"size\")(len)\nstandard_filter_manager.register(int)\nstandard_filter_manager.register(float)\nstandard_filter_manager.register(str)\nstandard_filter_manager.register(bool)\n\n\n@standard_filter_manager.registerDOCS\ndef split(base, sep):\n    \"\"\"Split a string into a list\n    If the sep is empty, return the list of characters\n    \"\"\"\n    if not sep:\n        return list(base)\n    return base.split(sep)\n\n\n@standard_filter_manager.registerDOCS\ndef append(base, suffix):\n    \"\"\"Append a suffix to a string\"\"\"\n    return f\"{base}{suffix}\"\n\n\n@standard_filter_manager.registerDOCS\ndef prepend(base, prefix):\n    \"\"\"Prepend a prefix to a string\"\"\"\n    return f\"{prefix}{base}\"\n\n\n@standard_filter_manager.registerDOCS\ndef times(base, sep):\n    \"\"\"Implementation of *\"\"\"\n    return base * sep\n\n\n@standard_filter_manager.registerDOCS\ndef minus(base, sep):\n    \"\"\"Implementation of -\"\"\"\n    return base - sep\n\n\n@standard_filter_manager.registerDOCS\ndef plus(base, sep):\n    \"\"\"Implementation of +\"\"\"\n    return base + sep\n\n\n@standard_filter_manager.registerDOCS\ndef modulo(base, sep):\n    \"\"\"Implementation of %\"\"\"\n    return base % sep\n\n\n@standard_filter_manager.registerDOCS\ndef ceil(base):\n    \"\"\"Get the ceil of a number\"\"\"\n    return math.ceil(float(base))\n\n\n@standard_filter_manager.registerDOCS\ndef floor(base):\n    \"\"\"Get the floor of a number\"\"\"\n    return math.floor(float(base))\n\n\n@standard_filter_manager.register(\"date\")DOCS\ndef liquid_date(base, fmt):\n    \"\"\"Format a date/datetime\"\"\"\n\n    if base == \"now\":\n        dtime = datetime.now()\n    elif base == \"today\":\n        dtime = datetime.today()\n    elif isinstance(base, (int, float)):\n        dtime = datetime.fromtimestamp(base)\n    else:\n        from dateutil import parser    # type: ignore\n        dtime = parser.parse(base)\n\n    return DateTime(dtime, fmt)\n\n\n@standard_filter_manager.registerDOCS\ndef default(base, deft, allow_false=False):\n    \"\"\"Return the deft value if base is not set.\n    Otherwise, return base\"\"\"\n    if allow_false and base is False:\n        return False\n    if base is None:\n        return deft\n    return FILTERS[\"default\"](base, deft, isinstance(base, str))\n\n\n@standard_filter_manager.registerDOCS\ndef divided_by(base, dvdby):\n    \"\"\"Implementation of / or //\"\"\"\n    if isinstance(dvdby, int):\n        return base // dvdby\n    return base / dvdby\n\n\n@standard_filter_manager.registerDOCS\ndef escape_once(base):\n    \"\"\"Escapse html characters only once of the string\"\"\"\n    return html.escape(html.unescape(base))\n\n\n@standard_filter_manager.registerDOCS\ndef newline_to_br(base):\n    \"\"\"Replace newline with `&lt;br /&gt;`\"\"\"\n    return base.replace(\"\\n\", \"&lt;br /&gt;\")\n\n\n@standard_filter_manager.registerDOCS\ndef remove(base, string):\n    \"\"\"Remove a substring from a string\"\"\"\n    return base.replace(string, \"\")\n\n\n@standard_filter_manager.registerDOCS\ndef remove_first(base, string):\n    \"\"\"Remove the first substring from a string\"\"\"\n    return base.replace(string, \"\", 1)\n\n\n@standard_filter_manager.registerDOCS\ndef replace_first(base, old, new):\n    \"\"\"Replace the first substring with new string\"\"\"\n    return base.replace(old, new, 1)\n\n\n# @standard_filter_manager.register\n# def reverse(base):\n#     \"\"\"Get the reversed list\"\"\"\n#     if not base:\n#         return EmptyDrop()\n#     return list(reversed(base))\n\n\n@standard_filter_manager.registerDOCS\ndef sort(base):\n    \"\"\"Get the sorted list\"\"\"\n    if not base:\n        return EmptyDrop()\n    return list(sorted(base))\n\n\n@standard_filter_manager.registerDOCS\ndef sort_natural(base):\n    \"\"\"Get the sorted list in a case-insensitive manner\"\"\"\n    if not base:\n        return EmptyDrop()\n    return list(sorted(base, key=str.casefold))\n\n\n@standard_filter_manager.register(\"slice\")DOCS\ndef liquid_slice(base, start, length=1):\n    \"\"\"Slice a list\"\"\"\n    if not base:\n        return EmptyDrop()\n    if start &lt; 0:\n        start = len(base) + start\n    end = None if length is None else start + length\n    return base[start:end]\n\n\n@standard_filter_manager.registerDOCS\ndef strip_html(base):\n    \"\"\"Strip html tags from a string\"\"\"\n    # use html parser?\n    return re.sub(r\"&lt;[^&gt;]+&gt;\", \"\", base)\n\n\n@standard_filter_manager.registerDOCS\ndef strip_newlines(base):\n    \"\"\"Strip newlines from a string\"\"\"\n    return base.replace(\"\\n\", \"\")\n\n\n@standard_filter_manager.registerDOCS\ndef truncate(base, length, ellipsis=\"...\"):\n    \"\"\"Truncate a string\"\"\"\n    lenbase = len(base)\n    if length &gt;= lenbase:\n        return base\n\n    return base[: length - len(ellipsis)] + ellipsis\n\n\n@standard_filter_manager.registerDOCS\ndef truncatewords(base, length, ellipsis=\"...\"):\n    \"\"\"Truncate a string by words\"\"\"\n    # do we need to preserve the whitespaces?\n    baselist = base.split()\n    lenbase = len(baselist)\n    if length &gt;= lenbase:\n        return base\n\n    # instead of collapsing them into just a single space?\n    return \" \".join(baselist[:length]) + ellipsis\n\n\n@standard_filter_manager.registerDOCS\ndef uniq(base):\n    \"\"\"Get the unique elements from a list\"\"\"\n    if not base:\n        return EmptyDrop()\n    ret = []\n    for bas in base:\n        if bas not in ret:\n            ret.append(bas)\n    return ret\n\n\n@standard_filter_manager.registerDOCS\ndef url_decode(base):\n    \"\"\"Url-decode a string\"\"\"\n    try:\n        from urllib import unquote\n    except ImportError:\n        from urllib.parse import unquote\n    return unquote(base)\n\n\n@standard_filter_manager.registerDOCS\ndef url_encode(base):\n    \"\"\"Url-encode a string\"\"\"\n    try:\n        from urllib import urlencode\n    except ImportError:\n        from urllib.parse import urlencode\n    return urlencode({\"\": base})[1:]\n\n\n@standard_filter_manager.registerDOCS\ndef where(base, prop, value):\n    \"\"\"Query a list of objects with a given property value\"\"\"\n    ret = [bas for bas in base if _get_prop(bas, prop) == value]\n    return ret or EmptyDrop()\n\n\n@standard_filter_manager.register([\"liquid_map\", \"map\"])DOCS\ndef liquid_map(base, prop):\n    \"\"\"Map a property to a list of objects\"\"\"\n    return [_get_prop(bas, prop) for bas in base]\n\n\n@standard_filter_manager.registerDOCS\ndef attr(base, prop):\n    \"\"\"Similar as `__getattr__()` but also works like `__getitem__()\"\"\"\n    return _get_prop(base, prop)\n\n\n# @standard_filter_manager.register\n# def join(base, sep):\n#     \"\"\"Join a list by the sep\"\"\"\n#     if isinstance(base, EmptyDrop):\n#         return ''\n#     return sep.join(base)\n\n# @standard_filter_manager.register\n# def first(base):\n#     \"\"\"Get the first element of the list\"\"\"\n#     if not base:\n#         return EmptyDrop()\n#     return base[0]\n\n# @standard_filter_manager.register\n# def last(base):\n#     \"\"\"Get the last element of the list\"\"\"\n#     if not base:\n#         return EmptyDrop()\n#     return base[-1]\n\n\n@standard_filter_manager.registerDOCS\ndef compact(base):\n    \"\"\"Remove empties from a list\"\"\"\n    ret = [bas for bas in base if bas]\n    return ret or EmptyDrop()\n\n\n@standard_filter_manager.registerDOCS\ndef regex_replace(\n    base: str,\n    regex: str,\n    replace: str = \"\",\n    case_sensitive: bool = False,\n    count: int = 0,\n) -&gt; str:\n    \"\"\"Replace matching regex pattern\"\"\"\n    if not isinstance(base, str):\n        # Raise an error instead?\n        return base\n\n    args = {\n        \"pattern\": regex,  # re.escape\n        \"repl\": replace,\n        \"string\": base,\n        \"count\": count,\n    }\n    if not case_sensitive:\n        args[\"flags\"] = re.IGNORECASE\n\n    return re.sub(**args)    # type: ignore\n</code></pre>"},{"location":"api/source/liquid.filters.wild/","title":"liquid.filters.wild","text":""},{"location":"api/source/liquid.filters.wild/","title":"SOURCE CODE liquid.filters.wild DOCS","text":"<pre><code>\"\"\"Provides some wild filters\"\"\"\n\ntry:\n    from jinja2 import pass_environment\nexcept ImportError:\n    from jinja2 import environmentfilter as pass_environment\n\nfrom typing import TYPE_CHECKING, Any, Callable\nfrom .manager import FilterManager\n\nif TYPE_CHECKING:\n    from jinja2.environment import Environment\n\nwild_filter_manager = FilterManager()\n\n\n@wild_filter_manager.register(\"ifelse, if_else\")DOCS\n@pass_environment\ndef ifelse(\n    env: \"Environment\",\n    value: Any,\n    test: Any,\n    test_args: Any = (),\n    true: Any = None,\n    true_args: Any = (),\n    false: Any = None,\n    false_args: Any = (),\n) -&gt; Any:\n    \"\"\"An if-else filter, implementing a tenary-like filter.\n\n    Use `ifelse` or `if_else`.\n\n    Examples:\n        &gt;&gt;&gt; {{ a | ifelse: isinstance, (int, ),\n        &gt;&gt;&gt;                \"plus\", (1, ),\n        &gt;&gt;&gt;                \"append\", (\".html\", ) }}\n        &gt;&gt;&gt; # 2 when a = 1\n        &gt;&gt;&gt; # \"a.html\" when a = \"a\"\n\n    Args:\n        value: The base value\n        test: The test callable or filter name\n        test_args: Other args (value as the first arg) for the test\n        true: The callable or filter name when test is True\n        true_args: Other args (value as the first arg) for the true\n            When this is None, return the true callable itself or the name\n            of the filter it self\n        false: The callable or filter name when test is False\n        false_args: Other args (value as the first arg) for the false\n            When this is None, return the false callable itself or the name\n            of the filter it self\n    Returns:\n        The result of true of test result is True otherwise result of false.\n    \"\"\"\n\n    def compile_out(func: Any, args: Any) -&gt; Any:\n        if args is None:\n            return func\n        if not isinstance(args, tuple):\n            args = (args,)\n        if callable(func):\n            return func(value, *args)\n        expr = env.compile_expression(f\"value | {func}(*args)\")\n        return expr(value=value, args=args)\n\n    test_out = compile_out(test, test_args)\n    if test_out:\n        return compile_out(true, true_args)\n    return compile_out(false, false_args)\n\n\n@wild_filter_manager.registerDOCS\ndef call(fn: Callable, *args, **kwargs) -&gt; Any:\n    \"\"\"Call a function with passed arguments\n\n    Examples:\n        &gt;&gt;&gt; {{ int | call: \"1\" | plus: 1 }}\n        &gt;&gt;&gt; # 2\n\n    Args:\n        fn: The callable\n        *args: and\n        **kwargs: The arguments for the callable\n\n    Returns:\n        The result of calling the function\n    \"\"\"\n    return fn(*args, **kwargs)\n\n\n@wild_filter_manager.registerDOCS\ndef each(array: Any, fn: Callable, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Call a function for each item in an array.\n\n    With wild mode, you can use the 'map' filter to apply a function to each\n    item in an array. However, this filter is different from the 'map' filter\n    in that it takes the array as the first argument and additional arguments\n    passed to the function are allowed.\n\n    Examples:\n        &gt;&gt;&gt; {{ floor | map: [1.1, 2.1, 3.1] | list }}\n        &gt;&gt;&gt; # [1, 2, 3]\n\n        &gt;&gt;&gt; {{ [1.1, 2.1, 3.1] | each: floor }}\n        &gt;&gt;&gt; # [1, 2, 3]\n        &gt;&gt;&gt; {{ [1.1, 2.1, 3.1] | each: plus, 1 }}\n        &gt;&gt;&gt; # [2.2, 3.2, 4.2]\n\n    Args:\n        array: The array\n        fn: The callable\n\n    Returns:\n        The result of calling the function for each item in the array\n    \"\"\"\n    return [fn(item, *args, **kwargs) for item in array]\n</code></pre>"},{"location":"api/source/liquid.liquid/","title":"liquid.liquid","text":""},{"location":"api/source/liquid.liquid/","title":"SOURCE CODE liquid.liquid DOCS","text":"<pre><code>\"\"\"Provides Liquid class\"\"\"\nimport builtins\nfrom typing import Any, Callable, Mapping\nfrom jinja2 import (\n    Environment,\n    ChoiceLoader,\n    FileSystemLoader,\n)\n\nfrom .filters.standard import standard_filter_manager\nfrom .utils import PathType, PathTypeOrIter\n\n\nclass Liquid:DOCS\n    \"\"\"The entrance for the package\n\n    Examples:\n        &gt;&gt;&gt; Liquid('{{a}}', from_file=False)\n        &gt;&gt;&gt; Liquid('template.html')\n\n    Args:\n        template: The template string or path of the template file\n        env: The jinja environment\n        from_file: Whether `template` is a file path. If True, a\n            `FileSystemLoader` will be used in the `env`.\n        mode: The mode of the engine.\n            - standard: Most compatibility with the standard liquid engine\n            - jekyll: The jekyll-compatible mode\n            - shopify: The shopify-compatible mode\n            - wild: The liquid- and jinja-compatible mode\n        filter_with_colon: Whether enable to use colon to separate filter and\n            its arguments (i.e. `{{a | filter: arg}}`). If False, will\n            fallback to use parentheses (`{{a | filter(arg)}}`)\n        search_paths: The search paths for the template files.\n            This only supports specification of paths. If you need so specify\n            `encoding` and/or `followlinks`, you should use jinja's\n            `FileSystemLoader`\n        globals: Additional global values to be used to render the template\n        filters: Additional filters be to used to render the template\n        filters_as_globals: Whether also use filters as globals\n            Only works in wild mode\n        **kwargs: Other arguments for an jinja Environment construction and\n            configurations for extensions\n    \"\"\"\n\n    __slots__ = (\"env\", \"template\")\n\n    def __init__(\n        self,\n        template: PathType,\n        from_file: bool = None,\n        mode: str = None,\n        env: Environment = None,\n        filter_with_colon: bool = None,\n        search_paths: PathTypeOrIter = None,\n        globals: Mapping[str, Any] = None,\n        filters: Mapping[str, Callable] = None,\n        filters_as_globals: bool = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        # default values\n        # fetch at runtime, so that they can be configured at importing\n        from .defaults import (\n            FROM_FILE,\n            MODE,\n            FILTER_WITH_COLON,\n            SEARCH_PATHS,\n            ENV_ARGS,\n            SHARED_GLOBALS,\n            FILTERS_AS_GLOBALS,\n        )\n\n        if from_file is None:\n            from_file = FROM_FILE\n        if mode is None:\n            mode = MODE\n        if filter_with_colon is None:\n            filter_with_colon = FILTER_WITH_COLON\n        if search_paths is None:\n            search_paths = SEARCH_PATHS\n        if filters_as_globals is None:\n            filters_as_globals = FILTERS_AS_GLOBALS\n\n        # split kwargs into arguments for Environment constructor and\n        # configurations for extensions\n        env_args = {}\n        ext_conf = {}\n        for key, val in kwargs.items():\n            if key in ENV_ARGS:\n                env_args[key] = val\n            else:\n                ext_conf[key] = val\n\n        loader = env_args.pop(\"loader\", None)\n        fsloader = FileSystemLoader(search_paths)  # type: ignore\n        if loader:\n            loader = ChoiceLoader([loader, fsloader])\n        else:\n            loader = fsloader\n\n        self.env = Environment(**env_args, loader=loader)\n        if env is not None:\n            self.env = env.overlay(**env_args, loader=loader)\n\n        self.env.extend(**ext_conf)\n        self.env.globals.update(SHARED_GLOBALS)\n\n        standard_filter_manager.update_to_env(self.env)\n        self.env.add_extension(\"jinja2.ext.loopcontrols\")\n        if filter_with_colon:\n            from .exts.filter_colon import FilterColonExtension\n\n            self.env.add_extension(FilterColonExtension)\n\n        if mode == \"wild\":\n            from .exts.wild import LiquidWildExtension\n            from .filters.wild import wild_filter_manager\n\n            self.env.add_extension(\"jinja2.ext.debug\")\n            self.env.add_extension(LiquidWildExtension)\n\n            bfilters = {\n                key: getattr(builtins, key)\n                for key in dir(builtins)\n                if not key.startswith(\"_\")\n                and callable(getattr(builtins, key))\n                and key\n                not in (\n                    \"copyright\",\n                    \"credits\",\n                    \"input\",\n                    \"help\",\n                    \"globals\",\n                    \"license\",\n                    \"locals\",\n                    \"memoryview\",\n                    \"object\",\n                    \"property\",\n                    \"staticmethod\",\n                    \"super\",\n                )\n                and not any(key_c.isupper() for key_c in key)\n            }\n            self.env.filters.update(bfilters)\n            wild_filter_manager.update_to_env(self.env)\n            self.env.globals.update(\n                {\n                    key: val\n                    for key, val in __builtins__.items()\n                    if not key.startswith(\"_\")\n                }\n            )\n            if filters_as_globals:\n                self.env.globals.update(standard_filter_manager.filters)\n                self.env.globals.update(wild_filter_manager.filters)\n\n        elif mode == \"jekyll\":\n            from .exts.front_matter import FrontMatterExtension\n            from .exts.jekyll import LiquidJekyllExtension\n            from .filters.jekyll import jekyll_filter_manager\n\n            jekyll_filter_manager.update_to_env(self.env)\n            self.env.add_extension(FrontMatterExtension)\n            self.env.add_extension(LiquidJekyllExtension)\n\n        elif mode == \"shopify\":\n            from .exts.shopify import LiquidShopifyExtension\n            from .filters.shopify import shopify_filter_manager\n\n            shopify_filter_manager.update_to_env(self.env)\n            self.env.add_extension(LiquidShopifyExtension)\n\n        else:  # standard\n            from .exts.standard import LiquidStandardExtension\n\n            self.env.add_extension(LiquidStandardExtension)\n\n        if filters:\n            self.env.filters.update(filters)\n\n        builtin_globals = {\n            \"int\": int,\n            \"float\": float,\n            \"str\": str,\n            \"bool\": bool\n        }\n        if globals:\n            builtin_globals.update(globals)\n        self.env.globals.update(builtin_globals)\n\n        if from_file:\n            # in case template is a PathLike\n            self.template = self.env.get_template(str(template))\n        else:\n            self.template = self.env.from_string(str(template))\n\n    def render(self, *args, **kwargs) -&gt; Any:DOCS\n        \"\"\"Render the template.\n\n        You can either pass the values using `tpl.render(a=1)` or\n        `tpl.render({'a': 1})`\n        \"\"\"\n        return self.template.render(*args, **kwargs)\n\n    async def render_async(self, *args, **kwargs) -&gt; Any:DOCS\n        \"\"\"Asynchronously render the template\"\"\"\n        return await self.template.render_async(*args, **kwargs)\n\n    @classmethodDOCS\n    def from_env(\n        cls,\n        template: PathType,\n        env: Environment,\n        from_file: bool = None,\n        filter_with_colon: bool = None,\n        filters_as_globals: bool = None,\n        mode: str = None,\n    ) -&gt; \"Liquid\":\n        \"\"\"Initiate a template from a jinja environment\n\n        You should not specify any liquid-related extensions here. They will\n        be added automatically.\n\n        No search path is allow to be passed here. Instead, use jinja2's\n        loaders or use the constructor to initialize a template.\n\n        @Args:\n            template: The template string or path of the template file\n            env: The jinja environment\n            from_file: Whether `template` is a file path. If True, a\n                `FileSystemLoader` will be used in the `env`.\n            filter_with_colon: Whether enable to use colon to separate filter\n                and its arguments (i.e. `{{a | filter: arg}}`). If False, will\n                fallback to use parentheses (`{{a | filter(arg)}}`)\n            filters_as_globals: Whether also use filters as globals\n                Only works in wild mode\n            mode: The mode of the engine.\n                - standard: Most compatibility with the standard liquid engine\n                - wild: The liquid- and jinja-compatible mode\n                - jekyll: The jekyll-compatible mode\n\n        @Returns:\n            A `Liquid` object\n        \"\"\"\n        return cls(\n            template,\n            env=env,\n            from_file=from_file,\n            filter_with_colon=filter_with_colon,\n            filters_as_globals=filters_as_globals,\n            mode=mode,\n        )\n</code></pre>"},{"location":"api/source/liquid/","title":"liquid","text":""},{"location":"api/source/liquid/","title":"SOURCE CODE liquid DOCS","text":"<pre><code>\"\"\"A port of liquid template engine for python on the shoulders of jinja2\"\"\"\nfrom .liquid import Liquid\nfrom .patching import patch_jinja, unpatch_jinja\n\npatch_jinja()\n\n__version__ = \"0.8.6\"\n</code></pre>"},{"location":"api/source/liquid.patching/","title":"liquid.patching","text":""},{"location":"api/source/liquid.patching/","title":"SOURCE CODE liquid.patching DOCS","text":"<pre><code>\"\"\"Patch a couple of jinja functions to implement some features\nthat are impossible or too complex to be implemented by extensions\n\nIncluding\n1. Patching Parser.parse to allow 'elsif' in addition to 'elif'\n2. Patching LoopContext to allow rindex and rindex0\n3. Adding liquid_cycle method to LoopContext to allow cycle to have a name\n4. Patching Parser.parse_for to allow arguments for tag 'for'\n\"\"\"\nfrom typing import Any\nfrom jinja2 import nodes\nfrom jinja2.parser import Parser\nfrom jinja2.runtime import LoopContext\n\nfrom .utils import parse_tag_args\n\n\n# patching Parser.parse_if to allow elsif in addition to elif\n# -----------------------------------------------------------\ndef parse_if(self) -&gt; nodes.Node:\n    node = result = nodes.If(lineno=self.stream.expect(\"name:if\").lineno)\n    while True:\n        node.test = self.parse_tuple(with_condexpr=False)\n        node.body = self.parse_statements(\n            (\"name:elif\", \"name:elsif\", \"name:else\", \"name:endif\")\n        )\n        node.elif_ = []\n        node.else_ = []\n        token = next(self.stream)\n        if token.test_any(\"name:elif\", \"name:elsif\"):\n            node = nodes.If(lineno=self.stream.current.lineno)\n            result.elif_.append(node)\n            continue\n        elif token.test(\"name:else\"):\n            result.else_ = self.parse_statements(\n                (\"name:endif\",), drop_needle=True\n            )\n        break\n    return result\n\n\njinja_nodes_if_fields = nodes.If.fields\njinja_parse_if = Parser.parse_if\n\n\n# patching LoopContext to allow rindex and rindex0\n# Also add liquid_cycle method to allow cycle to have a name\n# -----------------------------------------------------------\ndef cycle(self, *args: Any, name: Any = None) -&gt; Any:\n    if not hasattr(self, \"_liquid_cyclers\"):\n        setattr(self, \"_liquid_cyclers\", {})\n    cyclers = self._liquid_cyclers\n    if name not in cyclers:\n        cyclers[name] = [args, -1]\n    cycler = cyclers[name]\n    cycler[1] += 1\n    return cycler[0][cycler[1] % len(cycler[0])]\n\n\n# patching Parser.parse_for to allow arguments\n# -----------------------------------------------------------\ndef parse_for(self) -&gt; nodes.Node:\n    lineno = self.stream.expect(\"name:for\").lineno\n    target = self.parse_assign_target(extra_end_rules=(\"name:in\",))\n    self.stream.expect(\"name:in\")\n    iter = self.parse_tuple(\n        with_condexpr=False,\n        extra_end_rules=(\n            \"name:recursive\",\n            \"name:reversed\",\n            \"name:limit\",\n            \"name:offset\",\n        ),\n    )\n    reverse = self.stream.skip_if(\"name:reversed\")\n    limit = parse_tag_args(self.stream, \"limit\", lineno)\n    offset = parse_tag_args(self.stream, \"offset\", lineno)\n    if limit and offset:\n        limit = nodes.Add(offset, limit)\n    if limit or offset:\n        iter = nodes.Getitem(iter, nodes.Slice(offset, limit, None), \"load\")\n    if reverse:\n        iter = nodes.Filter(iter, \"reverse\", [], [], None, None)\n\n    test = None\n    if self.stream.skip_if(\"name:if\"):\n        test = self.parse_expression()\n    recursive = self.stream.skip_if(\"name:recursive\")\n    body = self.parse_statements((\"name:endfor\", \"name:else\"))\n    if next(self.stream).value == \"endfor\":\n        else_ = []\n    else:\n        else_ = self.parse_statements((\"name:endfor\",), drop_needle=True)\n    return nodes.For(target, iter, body, else_, test, recursive, lineno=lineno)\n\n\njinja_parse_for = Parser.parse_for\n\n\ndef patch_jinja():DOCS\n    \"\"\"Monkey-patch jinja\"\"\"\n    nodes.If.fields = jinja_nodes_if_fields + (\"elsif\",)\n    nodes.If.elsif = None\n    Parser.parse_if = parse_if\n\n    LoopContext.rindex = LoopContext.revindex\n    LoopContext.rindex0 = LoopContext.revindex0\n    LoopContext.liquid_cycle = cycle\n\n    Parser.parse_for = parse_for\n\n\ndef unpatch_jinja():DOCS\n    \"\"\"Restore the patches to jinja\"\"\"\n    nodes.If.fields = jinja_nodes_if_fields\n    del nodes.If.elsif\n\n    Parser.parse_if = jinja_parse_if\n    del LoopContext.rindex\n    del LoopContext.rindex0\n    del LoopContext.liquid_cycle\n\n    Parser.parse_for = jinja_parse_for\n</code></pre>"},{"location":"api/source/liquid.tags.jekyll/","title":"liquid.tags.jekyll","text":""},{"location":"api/source/liquid.tags.jekyll/","title":"SOURCE CODE liquid.tags.jekyll DOCS","text":"<pre><code>\"\"\"Provides jekyll tags\"\"\"\nimport os\n\nfrom jinja2 import nodes\nfrom jinja2.lexer import Token\nfrom jinja2.parser import Parser\n\nfrom .manager import TagManager\nfrom .standard import (\n    assign,\n    capture,\n    case,\n    comment,\n    cycle,\n    decrement,\n    increment,\n    tablerow,\n    unless,\n)\n\n\njekyll_tags = TagManager()\n\njekyll_tags.register(comment, raw=True)\njekyll_tags.register(capture)\njekyll_tags.register(assign)\njekyll_tags.register(unless)\njekyll_tags.register(case)\njekyll_tags.register(tablerow)\njekyll_tags.register(increment)\njekyll_tags.register(decrement)\njekyll_tags.register(cycle)\n\n\n# to specify certain named arguments\n# use jinja's with\n# https://stackoverflow.com/a/9405157/5088165\n@jekyll_tags.registerDOCS\ndef include_relative(token: Token, parser: Parser) -&gt; nodes.Node:\n    \"\"\"The {% include_relative ... %} tag\"\"\"\n    node = nodes.Include(lineno=token.lineno)\n    path = parser.parse_expression()\n    if parser.stream.filename:\n        node.template = nodes.Add(\n            nodes.Add(\n                nodes.Const(os.path.dirname(parser.stream.filename)),\n                nodes.Const(os.path.sep),\n            ),\n            path,\n        )\n    else:\n        node.template = path\n\n    node.ignore_missing = False\n    return parser.parse_import_context(node, True)\n</code></pre>"},{"location":"api/source/liquid.tags.manager/","title":"liquid.tags.manager","text":""},{"location":"api/source/liquid.tags.manager/","title":"SOURCE CODE liquid.tags.manager DOCS","text":"<pre><code>\"\"\"Provide tag manager\"\"\"\nimport re\nfrom base64 import b64decode\nfrom typing import TYPE_CHECKING, Callable, Dict, Set, Union\n\nfrom jinja2 import nodes\nfrom jinja2.exceptions import TemplateSyntaxError\n\nif TYPE_CHECKING:\n    from jinja2.lexer import Token\n    from jinja2.parser import Parser\n    from jinja2.environment import Environment\n\n\nfrom ..exts.ext import ENCODING_ID\n\nENCODED_PATTERN = re.compile(fr\"\\$\\${ENCODING_ID}\\$([\\w=+/]+)\\$\\$\")\n\n\ndef decode_raw(body: str) -&gt; str:DOCS\n    \"\"\"Decode the encoded string in body\n\n    The start string in body is encoded so that they won't be recognized\n    as variable/comment/block by jinja. This way, we can protect the body\n    from being tokenized.\n\n    Args:\n        body: The body\n\n    Returns:\n        The decoded string.\n    \"\"\"\n    return ENCODED_PATTERN.sub(\n        lambda m: b64decode(m.group(1)).decode(),\n        body,\n    )\n\n\nclass TagManager:DOCS\n    \"\"\"A manager for tags\n\n    Attributes:\n        tags: a mapping of tag names and parser functions\n        envs: a mapping of tag names and whether environment should be passed\n            to the parser functions\n        raws: a mapping of tag names and whether the tag body should be\n            kept raw.\n    \"\"\"\n\n    __slots__ = (\"tags\", \"envs\", \"raws\")\n\n    def __init__(self) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self.tags: Dict[str, Callable] = {}\n        self.envs: Dict[str, bool] = {}\n        self.raws: Dict[str, bool] = {}\n\n    def register(DOCS\n        self,\n        name_or_tagparser: Union[str, Callable] = None,\n        env: bool = False,\n        raw: bool = False,\n    ) -&gt; Callable:\n        \"\"\"Register a filter\n\n        This can be used as a decorator\n\n        Examples:\n            &gt;&gt;&gt; @tag_manager.register\n            &gt;&gt;&gt; def comment(token, parser):\n            &gt;&gt;&gt;     from jinja2 import nodes\n            &gt;&gt;&gt;     return nodes.Const(\"\")\n\n        Args:\n            name_or_tagparser: The tag parser to register\n                if name is given, will be treated as alias\n            env: Whether we should pass environment to the parser\n            raw: Whether we should keep the body of the tag raw\n\n        Returns:\n            The registered parser for the tag or a decorator\n        \"\"\"\n\n        def decorator(tagparser: Callable) -&gt; Callable:\n            name = tagparser.__name__\n            name = [name]  # type: ignore\n\n            if (\n                name_or_tagparser and name_or_tagparser is not tagparser\n            ):  # pragma: no cover\n                names = name_or_tagparser\n                if isinstance(names, str):\n                    names = (\n                        nam.strip() for nam in names.split(\",\")\n                    )  # type: ignore\n                name = names  # type: ignore\n\n            for nam in name:\n                self.tags[nam] = tagparser\n                self.envs[nam] = env\n                self.raws[nam] = raw\n\n            return tagparser\n\n        if callable(name_or_tagparser):\n            return decorator(name_or_tagparser)\n\n        return decorator\n\n    @propertyDOCS\n    def names(self) -&gt; Set[str]:\n        \"\"\"Get a set of the tag names\"\"\"\n        return set(self.tags)\n\n    @propertyDOCS\n    def names_raw(self) -&gt; Set[str]:\n        \"\"\"Get a set of names of tags whose body will be kept raw\"\"\"\n        return set(raw for raw in self.raws if self.raws[raw])\n\n    def parse(DOCS\n        self, env: \"Environment\", token: \"Token\", parser: \"Parser\"\n    ) -&gt; nodes.Node:\n        \"\"\"Calling the parser functions to parse the tags\n\n        Args:\n            env: The environment\n            token: The token matches the tag name\n            parser: The parser\n\n        Returns:\n            The parsed node\n        \"\"\"\n        tagname = token.value\n        if tagname not in self.tags:  # pragma: no cover\n            raise TemplateSyntaxError(\n                f\"Encountered unknown tag '{tagname}'.\",\n                token.lineno,\n            )\n\n        if self.envs.get(tagname, False):\n            return self.tags[tagname](env, token, parser)\n        return self.tags[tagname](token, parser)\n</code></pre>"},{"location":"api/source/liquid.tags/","title":"liquid.tags","text":""},{"location":"api/source/liquid.tags/","title":"SOURCE CODE liquid.tags DOCS","text":""},{"location":"api/source/liquid.tags.shopify/","title":"liquid.tags.shopify","text":""},{"location":"api/source/liquid.tags.shopify/","title":"SOURCE CODE liquid.tags.shopify DOCS","text":"<pre><code>\"\"\"Provide shopify tags\nsee: https://shopify.dev/api/liquid/tags\n\"\"\"\n\nfrom .manager import TagManager\nfrom .standard import (\n    comment,\n    capture,\n    assign,\n    unless,\n    case,\n    tablerow,\n    increment,\n    decrement,\n    cycle,\n)\n\n\nshopify_tags = TagManager()\n\nshopify_tags.register(comment, raw=True)\nshopify_tags.register(capture)\nshopify_tags.register(assign)\nshopify_tags.register(unless)\nshopify_tags.register(case)\nshopify_tags.register(tablerow)\nshopify_tags.register(increment)\nshopify_tags.register(decrement)\nshopify_tags.register(cycle)\n\n# https://shopify.dev/api/liquid/tags/theme-tags\n# TODO: echo, form, layout, liquid, paginate, render, section, style\n</code></pre>"},{"location":"api/source/liquid.tags.standard/","title":"liquid.tags.standard","text":""},{"location":"api/source/liquid.tags.standard/","title":"SOURCE CODE liquid.tags.standard DOCS","text":"<pre><code>\"\"\"Provides standard liquid tags\"\"\"\nfrom typing import TYPE_CHECKING, List, Union\nfrom jinja2 import nodes\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom jinja2.lexer import TOKEN_BLOCK_END, TOKEN_COLON, TOKEN_STRING\n\nfrom ..utils import peek_tokens, parse_tag_args\nfrom .manager import TagManager, decode_raw\n\nif TYPE_CHECKING:\n    from jinja2.parser import Parser\n    from jinja2.lexer import Token\n\n\nstandard_tags = TagManager()\n\n\n@standard_tags.register(raw=True)DOCS\ndef comment(token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The comment tag {% comment %} ... {% endcomment %}\n\n    This tag accepts an argument, which is the prefix to be used for each line\n    in the body.\n    If no prefix provided, the entire body will be ignored (works as the one\n    from liquid)\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    if parser.stream.current.type is TOKEN_BLOCK_END:\n        # no args provided, ignore whatever\n        parser.parse_statements((\"name:endcomment\", ), drop_needle=True)\n        return nodes.Output([], lineno=token.lineno)\n\n    args = parser.parse_expression()\n    body = parser.parse_statements((\"name:endcomment\", ), drop_needle=True)\n    body = decode_raw(body[0].nodes[0].data)\n    body_parts = body.split(\"\\n\", 1)\n    if not body_parts[0]:\n        body = \"\" if len(body_parts) &lt; 2 else body_parts[1]\n\n    out = [nodes.Const(f\"{args.value} {line}\\n\") for line in body.splitlines()]\n    return nodes.Output(out, lineno=token.lineno)\n\n\n@standard_tags.registerDOCS\ndef capture(token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The capture tag {% capture var %}...{% endcapture %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    target = parser.parse_assign_target(with_namespace=True)\n    filter_node = parser.parse_filter(None)\n    body = parser.parse_statements((\"name:endcapture\",), drop_needle=True)\n    return nodes.AssignBlock(target, filter_node, body, lineno=token.lineno)\n\n\n@standard_tags.registerDOCS\ndef assign(token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The assign tag {% assign x = ... %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    target = parser.parse_assign_target(with_namespace=True)\n    parser.stream.expect(\"assign\")\n    expr = parser.parse_tuple()\n    return nodes.Assign(target, expr, lineno=token.lineno)\n\n\n@standard_tags.registerDOCS\ndef unless(token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The unless tag {% unless ... %} ... {% endunless %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    node = result = nodes.If(lineno=token.lineno)\n    while True:\n        node.test = nodes.Not(\n            parser.parse_tuple(with_condexpr=False),\n            lineno=token.lineno,\n        )\n        node.body = parser.parse_statements(\n            (\"name:elif\", \"name:elsif\", \"name:else\", \"name:endunless\")\n        )\n        node.elif_ = []\n        node.else_ = []\n        token = next(parser.stream)\n        if token.test_any(\"name:elif\", \"name:elsif\"):\n            node = nodes.If(lineno=parser.stream.current.lineno)\n            result.elif_.append(node)\n            continue\n        if token.test(\"name:else\"):\n            result.else_ = parser.parse_statements(\n                (\"name:endunless\",), drop_needle=True\n            )\n        break\n    return result\n\n\n@standard_tags.registerDOCS\ndef case(token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The case-when tag {% case x %}{% when y %} ... {% endcase %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    lhs = parser.parse_tuple(with_condexpr=False)\n    # %}\n    if not parser.stream.skip_if(\"block_end\"):\n        raise TemplateSyntaxError(  # pragma: no cover\n            \"Expected 'end of statement block'\",\n            token.lineno,\n        )\n    token = next(parser.stream)\n    if token.type == \"data\":\n        if token.value.strip():\n            raise TemplateSyntaxError(\n                \"Expected nothing or whitespaces between case and when, \"\n                f\"but got {token}\",\n                token.lineno,\n            )\n        token = next(parser.stream)\n\n    if token.type != \"block_begin\":\n        raise TemplateSyntaxError(\n            \"Expected 'begin of statement block', \" f\"but got {token}\",\n            token.lineno,\n        )\n\n    token = parser.stream.expect(\"name:when\")\n    node = result = nodes.If(lineno=token.lineno)\n    while True:\n        node.test = nodes.Compare(\n            lhs,\n            [\n                nodes.Operand(\n                    \"eq\",\n                    parser.parse_tuple(with_condexpr=False),\n                )\n            ],\n            lineno=token.lineno,\n        )\n        node.body = parser.parse_statements(\n            (\"name:when\", \"name:else\", \"name:endcase\")\n        )\n        node.elif_ = []\n        node.else_ = []\n        token = next(parser.stream)\n        if token.test(\"name:when\"):\n            node = nodes.If(lineno=parser.stream.current.lineno)\n            result.elif_.append(node)\n            continue\n        if token.test(\"name:else\"):\n            result.else_ = parser.parse_statements(\n                (\"name:endcase\",), drop_needle=True\n            )\n        break\n    return result\n\n\n@standard_tags.registerDOCS\ndef tablerow(\n    token: \"Token\", parser: \"Parser\"\n) -&gt; Union[nodes.Node, List[nodes.Node]]:\n    \"\"\"The tablerow tag {% tablerow ... %} ... {% endtablerow %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    target = parser.parse_assign_target(extra_end_rules=(\"name:in\", ))\n    parser.stream.expect(\"name:in\")\n    iter_ = parser.parse_tuple(\n        with_condexpr=False,\n        extra_end_rules=(\"name:cols\", \"name:limit\", \"name:offset\"),\n    )\n\n    cols = parse_tag_args(parser.stream, \"cols\", token.lineno)\n    limit = parse_tag_args(parser.stream, \"limit\", token.lineno)\n    offset = parse_tag_args(parser.stream, \"offset\", token.lineno)\n\n    if limit and offset:\n        limit = nodes.Add(offset, limit)\n    if limit or offset:\n        iter_ = nodes.Getitem(iter_, nodes.Slice(offset, limit, None), \"load\")\n\n    if cols:\n        slice_start = nodes.Mul(nodes.Name(\"_tablerow_i\", \"load\"), cols)\n        inner_iter = nodes.Getitem(\n            iter_,\n            nodes.Slice(\n                slice_start,\n                nodes.Add(slice_start, cols),\n                None,\n            ),\n            \"load\",\n        )\n    else:\n        inner_iter: nodes.Getitem = iter_\n\n    inner_body = [\n        nodes.Output(\n            [\n                nodes.Const('&lt;td class=\"col'),\n                nodes.Getattr(nodes.Name(\"loop\", \"load\"), \"index\", \"load\"),\n                nodes.Const('\"&gt;'),\n            ]\n        ),\n        *parser.parse_statements((\"name:endtablerow\",), drop_needle=True),\n        nodes.Output([nodes.Const(\"&lt;/td&gt;\")]),\n    ]\n    tr_begin = nodes.Output(\n        [\n            nodes.Const('&lt;tr class=\"row'),\n            nodes.CondExpr(\n                nodes.Name(\"loop\", \"load\"),\n                nodes.Getattr(nodes.Name(\"loop\", \"load\"), \"index\", \"load\"),\n                nodes.Const(1),\n            ),\n            nodes.Const('\"&gt;'),\n        ]\n    )\n    tr_end = nodes.Output([nodes.Const(\"&lt;/tr&gt;\")])\n    inner_loop = nodes.For(\n        target, inner_iter, inner_body, [], None, False, lineno=token.lineno\n    )\n    if not cols:\n        return [tr_begin, inner_loop, tr_end]\n\n    # (iter_ | length) / cols\n    iter_length = nodes.Div(\n        nodes.Filter(iter_, \"length\", [], [], None, None),\n        cols,\n    )  # float\n    # int(iter_length)\n    iter_length_int = nodes.Filter(iter_length, \"int\", [], [], None, None)\n\n    # implement ceil, as jinja's ceil is implemented as round(..., \"ceil\")\n    # while liquid has a ceil filter\n    # iter_length_int if iter_length == iter_length_int\n    # else iter_length_int + 1\n    iter_length = nodes.CondExpr(\n        nodes.Compare(iter_length, [nodes.Operand(\"eq\", iter_length_int)]),\n        iter_length_int,\n        nodes.Add(iter_length_int, nodes.Const(1)),\n    )\n\n    return nodes.For(\n        nodes.Name(\"_tablerow_i\", \"store\"),\n        nodes.Call(nodes.Name(\"range\", \"load\"), [iter_length], [], None, None),\n        [tr_begin, inner_loop, tr_end],\n        [],\n        None,\n        False,\n        lineno=token.lineno,\n    )\n\n\n@standard_tags.registerDOCS\ndef increment(token: \"Token\", parser: \"Parser\") -&gt; List[nodes.Node]:\n    \"\"\"The increment tag {% increment x %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    variable = parser.stream.expect(\"name\")\n    varname = f\"_liquid_xcrement_{variable.value}\"\n    varnode = nodes.Name(varname, \"load\")\n\n    return [\n        nodes.Assign(\n            nodes.Name(varname, \"store\"),\n            nodes.CondExpr(\n                nodes.Test(varnode, \"defined\", [], [], None, None),\n                nodes.Add(varnode, nodes.Const(1)),\n                nodes.Const(0),\n            ),\n            lineno=token.lineno,\n        ),\n        nodes.Output([varnode], lineno=token.lineno),\n    ]\n\n\n@standard_tags.registerDOCS\ndef decrement(token: \"Token\", parser: \"Parser\") -&gt; List[nodes.Node]:\n    \"\"\"The decrement tag {% decrement x %}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    variable = parser.stream.expect(\"name\")\n    varname = f\"_liquid_xcrement_{variable.value}\"\n    varnode = nodes.Name(varname, \"load\")\n\n    return [\n        nodes.Assign(\n            nodes.Name(varname, \"store\"),\n            nodes.CondExpr(\n                nodes.Test(varnode, \"defined\", [], [], None, None),\n                nodes.Sub(varnode, nodes.Const(1)),\n                nodes.Const(-1),\n            ),\n            lineno=token.lineno,\n        ),\n        nodes.Output([varnode], lineno=token.lineno),\n    ]\n\n\n@standard_tags.registerDOCS\ndef cycle(token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The cycle tag {% cycle ... %}\n\n    With name: {% cycle \"name\": \"one\", \"two\", \"three\" %}\n    Without: {% cycle \"one\", \"two\", \"three\" %}\n\n    Turn these to\n    {{ loop.liquid_cycle(\"one\", \"two\", \"three\", name=...) }}\n\n    Args:\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    tokens_ahead = peek_tokens(parser.stream, 2)\n    if (\n        len(tokens_ahead) == 2\n        and tokens_ahead[0].type is TOKEN_STRING\n        and tokens_ahead[1].type is TOKEN_COLON\n    ):\n        parser.stream.skip(2)\n        cycler_name = tokens_ahead[0].value\n    else:\n        cycler_name = \"\"\n\n    args = parser.parse_tuple(with_condexpr=False, simplified=True)\n    return nodes.Output(\n        [\n            nodes.Call(\n                nodes.Getattr(\n                    nodes.Name(\"loop\", \"load\"), \"liquid_cycle\", \"load\"\n                ),\n                args.items if isinstance(args, nodes.Tuple) else [args],\n                [nodes.Keyword(\"name\", nodes.Const(cycler_name))],\n                None,\n                None,\n                lineno=token.lineno,\n            )\n        ]\n    )\n</code></pre>"},{"location":"api/source/liquid.tags.wild/","title":"liquid.tags.wild","text":""},{"location":"api/source/liquid.tags.wild/","title":"SOURCE CODE liquid.tags.wild DOCS","text":"<pre><code>\"\"\"Provides tags for wild mode\"\"\"\nimport textwrap\nfrom contextlib import redirect_stdout\nfrom io import StringIO\nfrom typing import TYPE_CHECKING, List, Union\n\nfrom jinja2 import nodes\nfrom jinja2.exceptions import TemplateSyntaxError\nfrom jinja2.lexer import TOKEN_BLOCK_END\n\ntry:\n    from jinja2 import pass_environment\nexcept ImportError:\n    from jinja2 import environmentfilter as pass_environment\n\nfrom .manager import TagManager, decode_raw\nfrom .standard import assign, capture, case, comment, cycle\n\nif TYPE_CHECKING:\n    from jinja2.lexer import Token\n    from jinja2.parser import Parser\n    from jinja2.environment import Environment\n\n\nwild_tags = TagManager()\n\nwild_tags.register(comment, raw=True)\nwild_tags.register(case)\nwild_tags.register(capture)\nwild_tags.register(assign)\nwild_tags.register(cycle)\n\n\n@wild_tags.register(raw=True, env=True)DOCS\ndef python(env: \"Environment\", token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The python tag\n\n    {% python %} ... {% endpython %} or\n    {% python ... %}\n\n    The globals from the enviornment will be used to evaluate the code\n    It also affect the globals from the environment\n\n    Args:\n        env: The environment\n        token: The token matches the tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    if parser.stream.current.type is TOKEN_BLOCK_END:\n        # expect {% endpython %}\n        body = parser.parse_statements((\"name:endpython\",), drop_needle=True)\n        body = decode_raw(body[0].nodes[0].data)\n        body_parts = body.split(\"\\n\", 1)\n        if not body_parts[0]:\n            body = \"\" if len(body_parts) &lt; 2 else body_parts[1]\n        body = textwrap.dedent(body)\n    else:\n        pieces: List[str] = []\n        pieces_append = pieces.append\n        while True:\n            token = next(parser.stream)\n            pieces_append(str(token.value))\n            if parser.stream.current.type is TOKEN_BLOCK_END:\n                break\n\n        body = \" \".join(pieces)\n\n    code = compile(body, \"&lt;liquid-python-tag&gt;\", mode=\"exec\")\n    out = StringIO()\n    with redirect_stdout(out):\n        exec(code, env.globals)\n    return nodes.Output([nodes.Const(out.getvalue())], lineno=token.lineno)\n\n\n@wild_tags.register(env=True)DOCS\ndef import_(\n    env: \"Environment\", token: \"Token\", parser: \"Parser\"\n) -&gt; nodes.Node:\n    \"\"\"The import_ tag {% import_ ... %}\n\n    Name it 'import_' so the 'import' tag from jinja can still work\n\n    Args:\n        env: The environment\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    pieces = [\"import\"]\n    pieces_append = pieces.append\n    while True:\n        token = next(parser.stream)\n        pieces_append(str(token.value))\n        if parser.stream.current.type is TOKEN_BLOCK_END:\n            break\n    body = \" \".join(pieces)\n    code = compile(body, \"&lt;liquid-import_-tag&gt;\", mode=\"exec\")\n    exec(code, env.globals)\n    return nodes.Output([], lineno=token.lineno)\n\n\n@wild_tags.register(env=True)DOCS\ndef from_(env: \"Environment\", token: \"Token\", parser: \"Parser\") -&gt; nodes.Node:\n    \"\"\"The from_ tag {% from_ ... %}\n\n    Name it 'from_' so the 'from_' tag from jinja can still work\n\n    Args:\n        env: The environment\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    pieces = [\"from\"]\n    pieces_append = pieces.append\n    while True:\n        token = next(parser.stream)\n        pieces_append(str(token.value))\n        if parser.stream.current.type is TOKEN_BLOCK_END:\n            break\n    body = \" \".join(pieces)\n    code = compile(body, \"&lt;liquid-from_-tag&gt;\", mode=\"exec\")\n    exec(code, env.globals)\n    return nodes.Output([], lineno=token.lineno)\n\n\n@wild_tags.register(env=True, raw=True)DOCS\ndef addfilter(\n    env: \"Environment\", token: \"Token\", parser: \"Parser\"\n) -&gt; nodes.Node:\n    \"\"\"The addfilter tag {% addfilter name ... %} ... {% endaddfilter %}\n\n    This allows one to use the python code inside the body to add a filter or\n    replace an existing filter\n\n    Args:\n        env: The environment\n        token: The token matches tag name\n        parser: The parser\n\n    Returns:\n        The parsed node\n    \"\"\"\n    token = parser.stream.expect(\"name\")\n    filtername = token.value\n\n    pass_env: Union[bool, Token]\n    if parser.stream.current.type is TOKEN_BLOCK_END:\n        # no pass_environment\n        pass_env = False\n    else:\n        pass_env = parser.stream.expect(\"name:pass_env\")\n\n    body = parser.parse_statements((\"name:endaddfilter\",), drop_needle=True)\n    body = decode_raw(body[0].nodes[0].data)\n    body_parts = body.split(\"\\n\", 1)\n    if not body_parts[0]:\n        body = \"\" if len(body_parts) &lt; 2 else body_parts[1]\n    body = textwrap.dedent(body)\n\n    globs = env.globals.copy()\n    code = compile(body, \"&lt;liquid-addfilter-tag&gt;\", mode=\"exec\")\n    exec(code, globs)\n    try:\n        filterfunc = globs[filtername]\n    except KeyError:\n        raise TemplateSyntaxError(\n            f\"No such filter defined in 'addfilter': {filtername}\",\n            token.lineno,\n        ) from None\n\n    if pass_env:\n        filterfunc = pass_environment(filterfunc)  # type: ignore\n    env.filters[filtername] = filterfunc\n\n    return nodes.Output([], lineno=token.lineno)\n</code></pre>"},{"location":"api/source/liquid.utils/","title":"liquid.utils","text":""},{"location":"api/source/liquid.utils/","title":"SOURCE CODE liquid.utils DOCS","text":"<pre><code>\"\"\"Some utils\"\"\"\nfrom os import PathLike\nfrom typing import TYPE_CHECKING, Iterable, List, Union\nfrom jinja2 import nodes\nfrom jinja2.lexer import TOKEN_INTEGER, TOKEN_NAME\nfrom jinja2.exceptions import TemplateSyntaxError\n\nif TYPE_CHECKING:\n    from jinja2.lexer import TokenStream, Token\n\nPathType = Union[PathLike, str]\nPathTypeOrIter = Union[PathType, Iterable[PathType]]\n\n\ndef peek_tokens(stream: \"TokenStream\", n: int = 1) -&gt; List[\"Token\"]:DOCS\n    \"\"\"Peek ahead 'n' tokens in the token stream, but don't move the cursor\n\n    Args:\n        stream: The token stream\n        n: n tokens to look at\n\n    Returns:\n        List of n tokens ahead.\n    \"\"\"\n    out = []\n    pushes = []\n    for _ in range(n):\n        out.append(next(stream))\n        pushes.append(stream.current)\n\n    for token in pushes:\n        stream.push(token)\n    stream.current = out[0]\n    return out\n\n\ndef parse_tag_args(DOCS\n    stream: \"TokenStream\", name: str, lineno: int\n) -&gt; nodes.Node:\n    \"\"\"Parse arguments for a tag.\n\n    Only integer and name are allowed as values\n\n    Examples:\n        &gt;&gt;&gt; \"{{tablerow product in products cols:2}}\"\n        &gt;&gt;&gt; parse_tag_args(stream, \"cols\", lineno)\n        &gt;&gt;&gt; # returns nodes.Const(2)\n\n    Args:\n        stream: The token stream\n        name: The name of the argument\n        lineno: The lineno\n\n    Returns:\n        None if the argument is not pressent otherwise a Const or Name node\n    \"\"\"\n    # use Parser.parse_primary?\n    arg = stream.skip_if(f\"name:{name}\")\n    if not arg:\n        return None\n\n    stream.expect(\"colon\")\n    # tokens_ahead = peek_tokens(stream)\n    if not stream.current.test_any(TOKEN_INTEGER, TOKEN_NAME):\n        raise TemplateSyntaxError(\n            f\"Expected an integer or a variable as argument for '{name}'.\",\n            lineno,\n        )\n\n    arg = next(stream)\n    if arg.type is TOKEN_INTEGER:\n        return nodes.Const(arg.value)\n    return nodes.Name(arg.value, \"load\")\n</code></pre>"}]}